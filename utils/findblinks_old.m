% findblinks.m: Take positional input data and return a list of points indicating% samples where blinks are occuring.  ('1' = 'good' data; '0' = blink.)% Called by 'deblink.m,' although it can be called manually.% input args  'pos': position data te be cleaned%             'thresh_p': pos threshold for onset of blink detection %             'thresh_v': vel threshold for onset of blink detection %             'thresh_a': acc threshold for onset of blink detection %             'pos_stop': pos threshold for end of blink detection %             'vel_stop': vel threshold for end of blink detection %             'acc_stop': acc threshold for end of blink detection %             'gap_fp': max # allowable sub-threshold pts in a fast-phase segment%             'gap_sp': max # allowable supra-threshold pts in a slow-phase segment%             'vel_or_acc': choose velocity or accel criterion for detection%% Requires 'd2pt.m' and 'maket.m' % The sampling frequency must be stored in a global variable named 'samp_freq'% written by:  Jonathan Jacobs%              November 2006 - December 2006 (last mod: 12/05/06)function [ptlist, pvlist] = findblinks( pos, thresh_p, pos_stop, thresh_v, vel_stop, ...									             thresh_a, acc_stop, extend )global debug_mode kb_ondiff_level = 5;  gap_fp = 10; gap_sp = 10;datalen = length(pos);% look for the deblinking windowsblink_cont = -1;wl = get(0,'Children');for i = 1:length(wl)   if strcmp(get(wl(i),'Name'),'Deblink Control'), blink_cont=wl(i);  endendif nargin == 0 && blink_cont>0   figure(blink_cont)   returnendif blink_cont>0   % retrieve the control handles   contH = get(blink_cont,'UserData');	knockoutH = contH{1};		dataNameH = contH{2};	use_posH = contH{3};			use_velH = contH{4};	use_accH = contH{5};			thresh_p_onH = contH{6};	thresh_p_offH = contH{7};	thresh_v_onH = contH{8};	thresh_v_offH = contH{9};	thresh_a_onH = contH{10};	thresh_a_offH = contH{11};	extendH = contH{12};	plot_velH = contH{13};		plot_accH = contH{14};	plot_acc_KO_H = contH{15};	plot_vel_KO_H = contH{16};		plot_pos_KO_H = contH{17};	plot_PV_H = contH{18};			helpH = contH{19};			aboutH = contH{20};				doneH = contH{21};			blink_result = contH{22};      ko_val       = get(knockoutH,'value');   dataName     = get(dataNameH,'String');   use_pos      = get(use_posH,'value');   use_vel      = get(use_velH,'value');   use_acc      = get(use_accH,'value');   thresh_p     = str2double(get(thresh_p_onH,'string')); 	thresh_v     = str2double(get(thresh_v_onH,'string'));   thresh_a     = str2double(get(thresh_a_onH,'string'));   pos_stop     = str2double(get(thresh_p_offH,'string'));   vel_stop     = str2double(get(thresh_v_offH,'string'));   acc_stop     = str2double(get(thresh_a_offH,'string'));   extend       = str2double(get(extendH,'string'));     else	% usually provided via GUI	if ~exist('use_pos','var'),      use_pos= 1; end	if ~exist('use_vel','var'),      use_vel= 1; end	if ~exist('use_acc','var'),      use_acc= 1; end	if ~exist('thresh_p','var'),     thresh_p = 40; end	if ~exist('thresh_v','var'),     thresh_v = 20; end	if ~exist('thresh_a','var'),     thresh_a = 20; end	if ~exist('pos_stop','var'),     pos_stop = 100; end	if ~exist('vel_stop','var'),     vel_stop = 10; end	if ~exist('acc_stop','var'),     acc_stop = 100; end	if ~exist('extend','var'),       extend = 5; end	if ~exist('dataName','var'),     dataName = 'unknown'; endend% convert input array from position to either vel or accel.vel = d2pt(pos, diff_level);acc = d2pt(vel, diff_level);% build a hit list.  at least one of the three criteria (p,v,a) must be% selected before we start.  begin with an empty array the size of the data.% apply each criterion in turn.hitlist  = zeros(datalen,1);misslist = zeros(datalen,1);pva =  4*use_pos + 2*use_vel + use_acc;switch pva	case 0		%% no selectiion		disp('Need to select at least one criterion')		return	case 1		%% accel		hitlist  = find(abs(acc) >= thresh_a);		misslist = find(abs(acc) <  thresh_a);		case 2		%% vel		hitlist  = find(abs(vel) >= thresh_v);		misslist = find(abs(vel) <  thresh_v);		case 3		%% a+v		hitlist  = find(abs(acc) >= thresh_a  |  abs(vel) >= thresh_v);		misslist = find(abs(acc) <  thresh_a & abs(vel) <  thresh_v);	case 4		%% pos		hitlist  = find(abs(pos) >= thresh_p);		misslist = find(abs(pos) <  thresh_p);		case 5		%% p+a		hitlist  = find(abs(acc) >= thresh_a | abs(pos) >= thresh_p);		misslist = find(abs(acc) <  thresh_a & abs(pos) <  thresh_p);		case 6		%% p+v		hitlist  = find(abs(vel) >= thresh_v | abs(pos) >= thresh_p);		misslist = find(abs(vel) <  thresh_v & abs(pos) <  thresh_p);		case 7		%% p+v+a		hitlist  = find(abs(acc) >= thresh_a | abs(vel) >= thresh_v | abs(pos) >= thresh_p);		misslist = find(abs(acc) <  thresh_a & abs(vel) <  thresh_v & abs(pos) <  thresh_p);		endif isempty(hitlist)   disp('findblinks: no points exceed the given thresholds.')   ptlist = ones(datalen,1);   pvlist = ones(datalen,1);  %%%%% <------- fix this?   returnend% complete guess. if it works, great.if isempty(misslist)   disp('findblinks: no misslist entries found.')   ptlist = ones(datalen,1);   pvlist = ones(datalen,1);  %%%%% <------- fix this?   return   disp(' * if you see this, save the workspace and call jon! * ')end   % Now we need to work 'inside-out' from the center of the blink to find% its beginning and end points.% Remember that the acceleration of a blink has pos AND neg humps% Blink is even uglier: may have period of zero (eye closed) surrounded by big values% (close eye and then open eye).  Also use pos record for blink detection% first, determine connectedness/locate gaps in the list% h3 values >1 mark gaps.h1 = [hitlist(1) hitlist'];h2 = [hitlist'   hitlist(end)];temp = h2 - h1;h3 = temp(2:end);m1 = [misslist(1) misslist'];m2 = [misslist'   misslist(end)];temp = m2 - m1;m3 = temp(2:end);%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 'q' is list of 'good' and 'bad' points in the data.% start with 'good' = sub-thresh, 'bad' = supra-thresh.% initialize 'nulls' array that 'q' will useq = ones(datalen,1);r = ones(datalen,1);   %% don't actually need 'r' array?q(hitlist) = 0;r(misslist) = 0;%diagnosticif debug_mode	figure('Name','findblink debug')	plot(acc)	hold on	plot(q*1.4*thresh_a,'b')	plot(r*1.3*thresh_a,'r')	if kb_on, keyboard; endend% the 'hit' and 'miss' lists will have little gaps where a few points dropped below% (or rose above) the treshold in an otherwise 'pure' run.  We want to plug those% little gaps.% For blinks: refine by marking intra-blink (NOT inter-) gaps as bad:% an intra-blink gap will have ~<10 points?%% gap greater than 20(?) marks beginning of next blinkblinkgaplist  = find(h3>1 & h3<=gap_fp);       % make these tunable argsslowgaplist  = find(m3>1 & m3<=gap_sp);       % make these tunable args% loop through the blinkgaplist% h2(blinkgaplist(i)) is 1st point of gap, h3(blinkgaplist(i)) is the length of the gapfor i = 1:length(blinkgaplist)   startpt = h2(blinkgaplist(i));   pluglen = h3(blinkgaplist(i));   q(startpt:startpt+pluglen-1) = 0;end% do same for slow phase interruptions.for i = 1:length(slowgaplist)   startpt = m2(slowgaplist(i));   pluglen = m3(slowgaplist(i));   q(startpt:startpt+pluglen-1) = 0;   %%% not 'r' array.endif debug_mode, plot(q*1.2*1000,'g'); if kb_on, keyboard; end; end  % diagnostic% next, look for the point when val is back to zero (or just beyond)q1 = [q' 0];q2 = [0 q'];temp = q1-q2;% 1st and last peaks are artifactsq3 = temp(2:end-1);%diagnosticif debug_mode, plot(q3*1.1*thresh_a,'r'); if kb_on, keyboard; end; end% segstart ia ALWAYS -1, regardless of dir of blinksegstart = find(q3 == -1);segstop  = find(q3 ==  1);if isempty(segstop), segstop = length(q3); end %%%% temp???% various sanity checks% 1) make sure that we are really starting with an ONSETif segstart(1)>segstop(1)   % there is NO "1st" blink. trim the 1st segstop since it is unpaired   segstop = segstop(2:end);   disp('warning: deleted unpaired initial segstop.')end% 2) make sure that we are really ending with an OFFSETif segstart(end)>segstop(end)   % trim the last segstart since it is unpaired   segstart = segstart(1:end-1);   disp('warning: unpaired final segstart found and deleted.')endif length(segstart) ~= length(segstop)   disp('findblinks: ERROR! -- #segstart ~= #segstop')    ptlist = ones(datalen,1);   returnend% Now for a bit of refinement.  So far, we've been working with segments% that contain partial blinks. Let's try to identify the ACTUAL % blink onsets and offsets by examining points beyond the segment to look% for when the acceleration (and perhaps velocity?) drops below a set thresh.% for each blink onsetlookback=100; crosspts = NaN(1,length(segstart));for i = 1:length(segstart)   %if i==15, keyboard; end   % look backwards up to ~100 samples (should be long enough for blink)   % but must protect against looking beyond the beginning of the data array   searchstop  = max(segstart(i)-lookback+1,1);   hist_b_acc  = acc(searchstop:segstart(i));   hist_b_vel  = vel(searchstop:segstart(i));   init_sign_a = sign(acc(segstart(i)));   init_sign_v = sign(vel(segstart(i)));   hb_len      = length(hist_b_acc);   % where accel falls below a given threshold (e.g. 100deg/s^2) or accel changes   % sign (to guarantee catching something), that's (almost) the end point.   % "Almost? Why not exactly?" you cry.  Because the accel has spread in time    % due to differentiation, we need to adjust the crossing points inward slightly.   % about five points should do it.  should this be hard coded, or left to user's   % preference with "extend" field in 'deblink'?   a_sign_change_pts = find(sign(hist_b_acc)~=init_sign_a);   if isempty(a_sign_change_pts), a_sign_change_pts = 0; end   pts_below_acc_thresh = find(abs(hist_b_acc)<=acc_stop);   if isempty(pts_below_acc_thresh), pts_below_acc_thresh = 0; end   stop_pt_acc = searchstop + max(a_sign_change_pts(end), pts_below_acc_thresh(end));       if isempty(stop_pt_acc), stop_pt_acc = segstart(i); end   stop_pt_acc = stop_pt_acc + 5;  %% <---- this is the band-aid line mentioned above   v_sign_change_pts = find(sign(hist_b_vel)~=init_sign_v);   if isempty(v_sign_change_pts), v_sign_change_pts = 0; end   pts_below_vel_thresh = find(abs(hist_b_vel)<=vel_stop);   if isempty(pts_below_vel_thresh), pts_below_vel_thresh = 0; end   stop_pt_vel = searchstop + max(v_sign_change_pts(end), pts_below_vel_thresh(end));   if isempty(stop_pt_vel), stop_pt_vel = segstart(i); end   % don't fall off the ends of the earth   cp_tempacc = max(stop_pt_acc(end), 1);   cp_tempvel = max(stop_pt_vel(end), 1);   % set the crossing point   vel_or_acc = 2;   switch (vel_or_acc)		case 1, crosspts(i,1) = cp_tempacc;		case 2, crosspts(i,1) = cp_tempvel;		case 3, crosspts(i,1) = fix((cp_tempacc+cp_tempvel)/2); %% use average?   end	%disp(['  segstart:' num2str(segstart(i))  ...	%		'  searchstop: ' num2str(searchstop)  ...	%		'  onset: ' num2str(crosspts(i,1))  ])     %% DIAGNOSTIC CODE   % plug it up   plugpts = crosspts(i,1):segstart(i);   q(plugpts) = zeros(size(plugpts));   % debug   if length(q) ~= datalen      segstop(i),length(q)      disp('ERROR in segstart.  Type ''break'' to continue')      if kb_on, keyboard; end      %break   endend% for each blink offsetlookahead = 100;for i = 1:length(segstop)   % look forwards up to ~100 samples (should be long enough for blink)   % but must protect against looking beyond the end of the data array   searchstop = min(segstop(i)+lookahead-1, datalen);   hist_f_acc = acc(segstop(i):searchstop);   hist_f_vel = vel(segstop(i):searchstop);   init_sign_a = sign(acc(segstop(i)));   init_sign_v = sign(vel(segstop(i)));   %hf_len = length(hist_f_acc);   % where accel falls below a given threshold (e.g. 100deg/s^2) or   % accel changes sign, that's the end point   a_sign_change_pts = find(sign(hist_f_acc)~=init_sign_a);   if isempty(a_sign_change_pts), a_sign_change_pts = lookahead; end   pts_below_acc_thresh = find(abs(hist_f_acc)<acc_stop);   if isempty(pts_below_acc_thresh), pts_below_acc_thresh = lookahead; end   stop_pt_acc  = segstop(i) + min(a_sign_change_pts(1), pts_below_acc_thresh(1));   if isempty(stop_pt_acc), stop_pt_acc = segstop(i); end   %stop_pt_acc = stop_pt_acc - 5;  %% <---- this is the band-aid line mentioned above   v_sign_change_pts = find(sign(hist_f_vel)~=init_sign_v);   if isempty(v_sign_change_pts), v_sign_change_pts=lookahead; end   pts_below_vel_thresh = find(abs(hist_f_vel)<=vel_stop);   if isempty(pts_below_vel_thresh), pts_below_vel_thresh=lookahead; end   stop_pt_vel = segstop(i) + min(v_sign_change_pts(1), pts_below_vel_thresh(1));   if isempty(stop_pt_vel), stop_pt_vel = segstop(i); end   % don't fall off the ends of the earth   cp_tempacc = min(stop_pt_acc(1), datalen);   cp_tempvel = min(stop_pt_vel(1), datalen);      % set the crossing point   switch (vel_or_acc)		case 1, crosspts(i,2) = cp_tempacc;		case 2, crosspts(i,2) = cp_tempvel;		case 3, crosspts(i,2) = fix((cp_tempacc+cp_tempvel)/2); %% use average?   end	%disp(['  segstop:' num2str(segstop(i))  ...	%		'  searchstop: ' num2str(searchstop)  ...	%		'  offset: ' num2str(crosspts(i,2)) ])    %% DIAGNOSTIC CODE      % plug it up   plugpts = segstop(i):crosspts(i,2);   q(plugpts) = zeros(size(plugpts));      % debug   if length(q) ~= datalen      segstop(i),length(q)      disp('ERROR in segstop.  Type ''break'' to continue')      if kb_on, keyboard; end      %break   endendif debug_mode, plot(q*thresh_a,'m'); if kb_on, keyboard; end; endif datalen ~= length(q)   disp('findblinks: ERROR! -- bad ptlist length!')   disp('Type ''break'' to continue')   if kb_on, keyboard; end   q = ones(datalen,1);end% check to see that the segments that we thought contained blinks actually do.% if it's 'really' a blink, PV must exceed the min threshold set in deblink.blinkstop = NaN(1,length(segstart)); pv_pt = NaN(1,length(segstart));pvel = NaN(1,length(segstart)); blinkstart = NaN(1,length(segstart));numFPs = 0;for i = 1:length(segstart)   seg  = abs(vel(segstart(i):segstop(i)));   peak = find(seg == max(seg));   if max(seg)>thresh_v      numFPs = numFPs + 1;      pv_pt(numFPs) = peak(end) + segstart(i) - 1;      pvel(numFPs)  = max(seg);      blinkstart(numFPs) = max(crosspts(i,1) - extend, 1);      blinkstop(numFPs)  = min(crosspts(i,2) + extend, datalen);   endend% real belt and suspenders stuff here.% we now have our list of blink starts and stops (given by the crosspoints)% we will ASSUME that all other points than those delimited by these crosspoints% not blinks.  remove only these points from a list of all points.% is there a down side?  yes.  we could re-include as SPh, points where the accel % and/or vel thresh was exceeded by funky eye mvmts or noise.q2 = ones(datalen,1);for i = 1:numFPs   q2(blinkstart(i):blinkstop(i)) = 0;end% basically, 'q2' can be considered 'strict' mode: only strictly defined blinks% are to be removed.  Conversely, 'q' is 'relaxed' mode, where any points that % exceed the threshold are used to build knockout.% debugif debug_mode   figure   plot(vel,'r')   hold on   plot(pv_pt,vel(pv_pt),'bo')   if kb_on, keyboard; endend% output argumentsstrict_strip = 1;switch strict_strip  case 1, ptlist = q2;  case 2, ptlist = q;endpvlist=pv_pt;% put all the results into the base workspace.assignin('base','ptlist',     ptlist) assignin('base','pvlist',     pv_pt)assignin('base','blinkstart', blinkstart)assignin('base','blinkstop',  blinkstop)assignin('base','pvel',       pvel)assignin('base','extend',     extend)assignin('base','dataName',   dataName)assignin('base','thresh_a',   thresh_p)assignin('base','thresh_v',   thresh_v)assignin('base','thresh_a',   thresh_a)assignin('base','vel_stop',   pos_stop)assignin('base','vel_stop',   vel_stop)assignin('base','acc_stop',   acc_stop)