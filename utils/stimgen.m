% stimgen.m: A primitive CLI program to generate stimuli used by the LabVIEW% acquisition/analog outpt VI. STIMGEN prompts the user for the duration of% stimulus, and for breakpoint/amplitude values.% The sampling frequency is 100 Hz, a value that was set by acq_disp_AO.vi% therefore times can be specified only within 0.01 seconds.% Usage: stim = stimgen;  (use of an output variable is optional)%% NOTE: stimgen creates LINEAR segments. Higher order fits%       (polynomial/exponential) might be considered at a later date.% Written by:  Jonathan Jacobs%              August 1998 - January 2009 (last mod: 01/30/09)function out = stimgen()maxampl =  35;cycledur = 5;commandwindowsamptemp = input('What is the sampling frequency for the stimulus? <default=100 Hz> ');if isempty(samptemp), samptemp = 100; endt_or_s = ' ';while t_or_s(1)~='t' && t_or_s(1)~='s'   commandwindow   t_or_s = lower(input('Use (T)ime or (S)ample number? ','s'));   if t_or_s ~= 's'      tstr = 'seconds';      sampf = samptemp;   else      tstr = 'samples';      sampf = 1;   endendbs = ' ';while bs(1)~='t' && bs(1)~='d'   commandwindow   bs=lower(input('Define by Segment (D)uration or Breakpoint (T)ime? ','s'));enddisp(' ')amplvect = [];figure;box; grid; hold onplot([0 cycledur],[NaN NaN]);xlabel('Time (sec)')ylabel('Stimulus Amplitude (deg)')title('STIMGEN output')if( bs(1)=='d' )   disp(' ')   disp('You will be prompted to enter durations and amplitudes')   disp('for each segment of the stimulus. The program will keep')   disp('accepting inputs until you enter a ''0'' to end.')   disp(' ')      segnum=1; running_dur=0; segbeg(1)=1/sampf; 	% 1st breakpoint is always 1/sampf      % enter segment durations. the breakpoint times will be calculated   %temp_seg_dur = 1;   while (1)      commandwindow      temp_seg_dur = input(['Enter the duration of segment ' num2str(segnum) ' in ' tstr ': ']);      if temp_seg_dur <= 0         cycledur = running_dur;         amplvect = amplvect(1:cycledur*sampf);         break      end            running_dur = temp_seg_dur+running_dur;      if running_dur > cycledur         cycledur = running_dur;         set(gca, 'xlim', [0 cycledur]);      end                  segend(segnum)   = segbeg(segnum)+temp_seg_dur - 1/sampf;      segbeg(segnum+1) = segbeg(segnum)+temp_seg_dur;            % segment start amplitude      ampl_beg(segnum) = -10000;      while abs(ampl_beg(segnum))>maxampl         commandwindow         ampl_beg(segnum) = input(['Enter the amplitude for the start of the segment.'...            ' (time T = ' num2str(segbeg(segnum)) ' ' tstr '): ']);      end            % segment end amplitude      ampl_end(segnum) = -10000;      while abs(ampl_end(segnum))>maxampl         commandwindow         ampl_end(segnum) = input(['Enter the amplitude for the end of the segment.'...            ' (time T = ' num2str(segend(segnum)) ' ' tstr '): ']);      end      disp(' ')                  % make the segment.      ampldelta = ampl_end(segnum)-ampl_beg(segnum);      seglen = round(temp_seg_dur*sampf);      timevect = 1:seglen;      %generate a new segment if there is more than one point      if length(timevect)>1         if ampldelta            %calculated segment            temp_amplvect = (ampl_beg(segnum):ampldelta/(length(timevect)-1):ampl_end(segnum));         else            %constant segment            temp_amplvect = ampl_beg(segnum)*ones(size(timevect));         end         % make sure the new segment is the right length         if length(temp_amplvect) ~= seglen            error('Error!!!!  Segment length error!!!')         end      else         disp('seglen == 1');         keyboard         return         %amplvect(timevect)=ampl(ind+1);      end            amplvect = [amplvect temp_amplvect];      % plot the segment      t=maket(amplvect,sampf);      plot(t,amplvect);      segnum=segnum+1;   end   % %%%% warning : this was not ever used regularly and was not updated to work% %%%% like the segment duration code. It will most likely break badly.% elseif( bs(1)=='b' || bs(1)=='t')%    %    disp('feature currently not implemented.')  %%%%%%    return%    %    disp(' ')%    disp('You will be prompted to enter breakpoints and amplitudes')%    disp('for each segment of the stimulus. The program will keep')%    disp('accepting inputs until you enter the breakpoint equal to')%    disp('the duration of the stimulus.')%    disp(' ')%    %    ind = 1;%    while abs(ampl(1))>maxampl%       ampl(1) = input(['Enter the amplitude at time T = 0 ' tstr ': ']);%    end%    disp(' ')%    %    bp = 0;%    % enter breakpoint times directly%    while (bp(ind) < cycledur)%       ind=ind+1;%       bp(ind)=-100000;%       while bp(ind) < bp(ind-1)%          temp = input(['Enter the time of breakpoint ' num2str(ind)...%             ' in ' tstr ': ']);%          bp(ind) = fix(temp*sampf)/sampf;%          %          if bp(ind) == bp(ind-1)%             disp('*** Same as previous breakpoint -- adjusting by one timestep. ***')%             bp(ind) = bp(ind)+ 1/sampf;%          end%       end%       %       ampl(ind) = -1000;%       while abs(ampl(ind))>maxampl%          ampl(ind) = input(['Enter the amplitude at time T = '...%             num2str(bp(ind)) ' ' tstr ': ']);%       end%       disp(' ')%       %       ampldelta = ampl(ind) - ampl(ind-1);%       timevect = (fix(bp(ind-1)*sampf)+1 : fix(bp(ind)*sampf));%       %generate a new segment if there is more than one point%       if length(timevect)>1%          if ampldelta%             %calculated segment%             amplvect(timevect) = ...%                (ampl(ind-1) : ampldelta/(length(timevect)-1) : ampl(ind) );%          else%             %constant segment%             amplvect(timevect) = ampl(ind-1)*ones(size(timevect));%          end%       else%          %disp('seglen == 1');%          amplvect(timevect)=ampl(ind);%       end%       tempLin1H = plot(timevect/sampf,amplvect(timevect))%       if ind>2%          tempLin2H = line([bp(ind-2) bp(ind-1)], [ampl(ind-2) ampl(ind-1)])%       end     %    end %while%    [ampl; bp];   end %if bs(1)% is this a 1-D or a 2-D stimulus?  If 2-D we need to specify which plane and the contents% (if any) of the other plane.disp(' ')commandwindowmultidim = input('Do you want to add this to an existing 1-D stim (y/n)? ', 's');if strcmpi(multidim,'y')   [hor,vrt] = loadcomponent(amplvect,samptemp);else  % single dimension   hor=amplvect;   vrt=[];end% create and show multi-cycle stimulusamplvect = [];commandwindownumcycles = input('Enter the number of cycles for the TOTAL stimulus: ');if numcycles > 1   for k=1:numcycles      amplvect  = cat(1,amplvect,[hor vrt]);   end      figure   t=maket(amplvect(:,1),sampf);   plot(t,amplvect)   xlabel(['Time (' tstr ')'])   ylabel('Stimulus Amplitude (deg)')   title('STIMGEN output')end%tt=repmat(char(9),size(hor));hstr=num2str(amplvect(:,1),4);vstr=num2str(amplvect(:,2),4);amplstr=[];for z=1:length(hor)   amplstr = cat(1,amplstr, [hstr(z), char(9), vstr(z), newline]);enddisp(' ')disp('If you are happy with this result, you can save it as an ASCII file.')disp('Otherwise, run "STIMGEN" again.')commandwindowyorn=lower(input('Write this to file (y/n)? ','s'));if yorn=='y'   [file, path] = uiputfile('*.stm', 'Save As');else   returnendif file == 0   disp('Canceled.')   returnendif isempty(strfind(file, '.stm')) %#ok<STREMP>   file = [file '.stm'];endfid=fopen([path file],'w');fprint(fid,amplstr);fclose(fid);disp(['"' file '" written to "' path '"'])if nargout == 0   clear out   returnelse   out = amplvect;end%end %function stimgenfunction [hor,vrt] = loadcomponent(firstcomp,samptemp)if ~exist('samptemp','var'), samptemp=100; end% get the other component -- embedded in while loop -- keep trying until happy with selection% main loop is terminated by a successful selection (one that meets all the criteria that% are being tested by the inner loops). inner loops are terminated by a break when successfulisSelected = 0;while ~isSelected      isAscii = 0;      while (~isAscii)      [filename, pathname] = uigetfile('*.*','Select a ''.stm'' file');      if filename == 0         secondcomp=[];         break      else         try            secondcomp = load(['' pathname filename '']);            isAscii = 1;         catch            disp('You did not select an ASCII stimulus file. Try again.')         end               end   end  %%while isAscii         % check dimensions of the loaded second component. Must be only one dimensional.   % it is easier to work with row-oriented data for now (1 sample/column)   [r1,c1]=size(firstcomp);   if c1>r1, firstcomp=firstcomp'; end   [r2,c2]=size(secondcomp);   if c2>r2, secondcomp=secondcomp'; end      isOneDim = 0;   numchans = min(r2,c2);   if numchans <= 1, isOneDim = 1; end   while isAscii && ~isOneDim      t=maket(secondcomp,samptemp);      colorlist = ['b', 'r', 'g', 'm', 'c'];      colorstrings = [{'(b)lue'}, {' (r)ed'}, {' (g)reen'}, {' (m)agenta'}, {' (c)yan'}];      colordef white      colorselectstr = '';      figure; hold on      for i = 1:numchans         plot(t,secondcomp(i,:),colorlist(i) )         colorselectstr = [colorselectstr colorstrings{i}];      end      if min(r2,c2) > 1         % if it is a multi-channel stim let user select one of the channels.         disp(['This file has ' num2str(numchans) ' channels.'])         commandwindow         whichchan = lower(input(['Which channel do you want [' colorselectstr ']? '],'s'));         switch whichchan            case {'b','blue'}               chanindex=1;            case {'r','red'}               chanindex=2;            case {'g','green'}               chanindex=3;            case {'m','magenta'}               chanindex=4;            case {'c','cyan'}               chanindex=5;            otherwise               isOneDim=0;               break         end         isOneDim=1;         secondcomp = secondcomp(chanindex,:);      end         end % while (isAscii & ~isOneDim)      % is the loaded component the same length as the generated component?  if not,   % offer to trim/padone or the other, then disp the two components together.   if length(firstcomp) > length(secondcomp)      disp('The loaded stimulus is shorter than the just-created one.')      disp('I will pad it to the same length.')      padlen = length(firstcomp)-length(secondcomp);      secondcomp = [secondcomp zeros(1,padlen)];   elseif  length(firstcomp) < length(secondcomp)      disp('The loaded stimulus is longer than the just-created one.')      disp('I will truncate it to the same length.')      secondcomp = secondcomp(1:length(firstcomp));   end      commandwindow   h_or_v = input('Will the loaded stimulus be the (h)orizontal or the (v)ertical component? ' ,'s');   if strcmpi(h_or_v,'v')      hor = firstcomp;      vrt = secondcomp;   else      hor = firstcomp;      vrt = secondcomp;   end   % is this what you wanted?   t=maket(hor,samptemp);   newfig=figure;   %figure(componentfigure)   subplot(2,1,1)   plot(t,hor)   ylabel('Hor. Stim.')   subplot(2,1,2)   plot(t,vrt)   ylabel('Vrt. Stim.')   xlabel('Time')      commandwindow   happy = input('Are you happy with this result (y/n)? ','s');   if strcmpi(happy, 'y')      %;   else      isAscii = 0;   end   close(newfig)         % reasons to exit the loop:  1) we've canceled file selection   %                         or 2) we've satisfied all requirements   if isempty(secondcomp), break; end   isSelected = isAscii & isOneDim;end