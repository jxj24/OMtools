% ebAct3D.m: Called by 'eyeballs3D' to perform all the callback actions%% Written by: Jonathan Jacobs%             March 2002 - May 2005 (last mod: 05/11/05)% Files necessary for proper operation:%   'eyeballs3d', 'ebAct3D.m', 'datscale.m', 'd2pt.m', 'axispad.m',%   'xyplotsettings.m', 'ebdatacheck.m', 'ebdataload.m'%%% Major updates and fixes:% 27 Nov 02: Added alignment crosshairs.  May eventually make them%  2 Dec 02: Added 'crossH' variable; allow turning crosshairs on/off %            The wform, monitor and control windows created at proper size,%              rather than resizing them after creation.% 29 May 03: Massive redesign of GUI, relocation of many controls%            Added user-customizable XY plot settings.%            'play' reads settings from XY plot's axis and applies values%              to XY plot playback%  2 Jun 03: Major revision now allows loading of new data w/o having to %              close and re-run 'eyeballs3d'%  5 Jun 03: User can now select arrays from the base workspace for XY plot% 16 Jul 03: Added optional display of stimulus data% 14 Oct 03: Added rubberband zoom% 12 Jan 05: Rewrote movie making code, prefs.  reorganized movie prefs.%            Render animation using 'zbuffer' workaround for 'OpenGL' bug.  %            User can now specify QT (if available), AVI, or series of JPEGs% 21 Jan 05: Eyeball and waveform windows are now easily resizable via %              slider/text box controls% 28 Jan 05: Thanks to effing Microsoft's crap handling of non-native graphics%					and movie formats, eyeballs now can be rendered w/o grid lines%              so the drastically reduced quality in PowerPoint is not as easily%              noticable.% 01 Feb 05: scale values are stored in the wf FIGURE'S 'UserData' now,%              rather than in that for the individual AXES'.%              This fixes the necessity of the axes being displayed in the wf%              window for scaling to be available.% 02 Feb 05: added extra cells to wf_axXY 'UserData' field as placeholders%              for the phase plane data arrays to enable stepping through%              the data ONLY AFTER it has been played at least once.% 09 May 05: zillions of little fixes.  wf window resizes properly and is drawn%              at the proper size at startup.  cosmetic rejiggering of axis sizes and%              positions when resizing the wf window.  'Stop' slider restored to%              proper position following cancellation of playback.  %              Adjusting start/current/stop sliders when XY plot is enabled, but%              before 1st playback no longer causes a crash.%              'xyplotsettings' has been extensively updated.% valid commands ('buttName' arg string):%   about, rbzoom, resize, speed, eyelight, eyeliner %   start_txt, start_sli, stop_txt, stop_sli %   cur_txt, cur_sli, f_cur, f_start, f_stop %   xy_setup, play!, hvt_update%   color, crosshairs, tormrkr, wf_draw%   load_data, movieprefs, done!function ebAct3D( buttName )global rh lh rv lv rt lt st sv samp_freqcomp=computer;vers=version;if comp(1)=='M' & vers(1)=='5'   moviemode = 'qt';  else   moviemode = 'avi';endif vers(1) >= '6'   degstr = '\circ';   pmstr  = '\pm'; else   if comp(1) == 'M'     degstr = '¡';     pmstr = '±';   else     degstr = ' deg';     dpmtr = '+/-';   endend % look for the open windowsefig = -1; cfig = -1; wfig = -1; sfig = -1; xyfig = -1;wl = get(0,'Children');for i = 1:length(wl)   if strcmp(get(wl(i),'Name'),'Eye Monitor'),           efig=wl(i);  end   if strcmp(get(wl(i),'Name'),'Eye Monitor Control'),   cfig=wl(i);  end   if strcmp(get(wl(i),'Name'),'Waveform Monitor'),      wfig=wl(i);  end   if strcmp(get(wl(i),'Name'),'Data Scaling & Offset'), sfig=wl(i);  end   if strcmp(get(wl(i),'Name'),'XY Plot settings'),   	xyfig=wl(i); endendif cfig<1, disp('Control Window does not exist. Yikes.'); return; endif wfig<1, disp('Waveform Window does not exist. Yikes.'); return; endif efig<1, disp('Eyeballs Window does not exist. Yikes.'); return; end%if pfig<1, disp('Phase Plane Window does not exist. Yikes.'); return; end% verify that there is good data in memory% should not need this here, once 'ebdataload' is in callback for 'load data' button%[status, datlen, noHOR, noVRT, noTOR, noSTM] = ebdatacheck;%if status==0, break; end% retrieve the handles for the eyeball window objects.  They were declared% in 'eyeballs3D'.eH = get(efig,'UserData');osSocket = eH(1);		os = eH(2);		osMrkr = eH(3);odSocket = eH(4);		od = eH(5);		odMrkr = eH(6);		overlay = eH(7);% retrieve the handles for the control window objects.  They were declared% in 'eyeballs3D'.cH=get(cfig,'UserData');plotHORh=cH(1);		plotVRTh=cH(2);		plotTORh=cH(3);   	null=cH(4); null=cH(5);				pauseBH=cH(6);			decimateH=cH(7);  	fpsH=cH(8);livemonBH=cH(9);		e_movieBH=cH(10);		wf_movieBH=cH(11);	null=cH(12);eb_size_sli=cH(13);	wf_size_sli=cH(14);	null=cH(15);eb_size_txt=cH(16);	wf_size_txt=cH(17);	null=cH(18);start_sli=cH(19);		stop_sli=cH(20);		cur_sli=cH(21);start_txt=cH(22);		stop_txt=cH(23);		cur_txt=cH(24);start_txt2=cH(25);	stop_txt2=cH(26);		cur_txt2=cH(27);movPrefsBH=cH(28);	crossH=cH(29);			plotXYh=cH(30);     xysetBH=cH(31);		stopBH=cH(32);			plotSTMh=cH(33);		rbzoomBH=cH(34);eyelinerBH=cH(35);	eyelightBH=cH(36);	% retrieve the handles for the waveform window objects. They will be all% zeros when initialized in 'eyeballs3D'. Almost immediately after this% initialization, 'ebAct3D('wf_draw')' was called and the handles then have% their proper values.  There is a fine line between tricky and skanky.temp=get(wfig,'UserData');planes=temp{1}; wH=temp{2}; o_and_s=temp{3}; wf_ax_inited=temp{4};wf_axLH=wH(1);  wf_overLH=wH(2);  wf_axLV=wH(3);    wf_overLV=wH(4);wf_axLT=wH(5);  wf_overLT=wH(6);  wf_axRH=wH(7);    wf_overRH=wH(8);wf_axRV=wH(9);  wf_overRV=wH(10); wf_axRT=wH(11);   wf_overRT=wH(12);wf_axXY=wH(13); wf_dataXY=wH(14); wf_overXY=wH(15); %%%%%%%%%%%eyeliner = get(eyelinerBH,'Value');eyelight = get(eyelightBH,'Value');eyeColor = get(od,'UserData');% because we could be working with data loaded after the initial% setup of the controls, we must reset the controls' max rangedatlen=length(lh);set(start_sli,'Max', datlen);set(stop_sli, 'Max', datlen);set(cur_sli,  'Max', datlen);startpt=round(get(start_sli,'Value'));if startpt>datlen, startpt=1;      set(start_sli,'Value',startpt); endstoppt=round(get(stop_sli,'Value'));if stoppt>datlen,  stoppt=datlen;  set(stop_sli, 'Value',stoppt);  endcurpt=round(get(cur_sli,'Value'));if curpt>datlen,   curpt=startpt;  set(cur_sli,  'Value',curpt);   endlivemonitor=get(livemonBH,'Value');playstep=fix(str2num(get(decimateH,'String')));fps = samp_freq/playstep;t=(1:length(lh))/samp_freq;% make sure we have the most recent movie making prefsmovtemp=get(movPrefsBH,'UserData');qtcompressor = movtemp{1};   spatialqual  = movtemp{2};makeqtmovie  = movtemp{3};   imageformat  = movtemp{4};movie_speed  = movtemp{5};   make_avi     = movtemp{6};make_stills  = movtemp{7};% Four possible axes to draw: hor, vrt, tor and phase plane (ppl)plotHOR = findstr(planes,'h'); if isempty(plotHOR),plotHOR = 0; endplotVRT = findstr(planes,'v'); if isempty(plotVRT),plotVRT = 0; endplotTOR = findstr(planes,'t'); if isempty(plotTOR),plotTOR = 0; endplotHOR = plotHOR & get(plotHORh,'Value');plotVRT = plotVRT & get(plotVRTh,'Value');plotTOR = plotTOR & get(plotTORh,'Value');plotXY  = get(plotXYh, 'Value');numplanes = sum(plotHOR + plotVRT + plotTOR);num_ax = 2*numplanes;% since XY uses only one axisnumplanes = numplanes + sum(plotXY);if plotXY, num_ax = num_ax+1; end%%% Data scaling and offsetting is checked/performed EVERY time ebAct3D%%% is called, to guarantee that the most up-to-date modifications are%%% being used.% if the scaling and offset window is open, the offset & scaling% factors will be read directly from its controls.% if it is NOT open, check to see if the wf window has been initialized.% if so, there are previously-set o&s values stored in the fig's 'UserData'.% if the window is brand new, then initialize o&s values to 0 & 1.if sfig > 0   % get the o/s control handles   hlist = get(sfig,'UserData');   rh_scaleH=hlist(1);   rv_scaleH=hlist(2);   rt_scaleH=hlist(3);   rh_offsetH=hlist(4);  rv_offsetH=hlist(5);  rt_offsetH=hlist(6);   lh_scaleH=hlist(7);   lv_scaleH=hlist(8);   lt_scaleH=hlist(9);   lh_offsetH=hlist(10); lv_offsetH=hlist(11); lt_offsetH=hlist(12);   	lh_scale=str2num(get(lh_scaleH,'String'));	rh_scale=str2num(get(rh_scaleH,'String'));	lv_scale=str2num(get(lv_scaleH,'String'));	rv_scale=str2num(get(rv_scaleH,'String'));	lt_scale=str2num(get(lt_scaleH,'String'));	rt_scale=str2num(get(rt_scaleH,'String'));	lh_offset=str2num(get(lh_offsetH,'String'));	rh_offset=str2num(get(rh_offsetH,'String'));	lv_offset=str2num(get(lv_offsetH,'String'));	rv_offset=str2num(get(rv_offsetH,'String'));	lt_offset=str2num(get(lt_offsetH,'String'));	rt_offset=str2num(get(rt_offsetH,'String')); elseif wf_ax_inited	offset = o_and_s{1}; scale = o_and_s{2};		rh_scale=scale(1,1); rh_offset=offset(1,1);	lh_scale=scale(1,2); lh_offset=offset(1,2);	rv_scale=scale(2,1); rv_offset=offset(2,1);	lv_scale=scale(2,2); lv_offset=offset(2,2);	rt_scale=scale(3,1); rt_offset=offset(3,1);	lt_scale=scale(3,2); lt_offset=offset(3,2); else   lh_scale=1; lv_scale=1; lt_scale=1; lh_offset=0; lv_offset=0; lt_offset=0;   rh_scale=1; rv_scale=1; rt_scale=1; rh_offset=0; rv_offset=0; rt_offset=0;endlhs = lh*lh_scale + lh_offset; rhs = rh*rh_scale + rh_offset;lvs = lv*lv_scale + lv_offset; rvs = rv*rv_scale + rv_offset;lts = lt*lt_scale + lt_offset; rts = rt*rt_scale + rt_offset;maxLHS=max(lhs(startpt:stoppt)); minLHS=min(lhs(startpt:stoppt));maxLVS=max(lvs(startpt:stoppt)); minLVS=min(lvs(startpt:stoppt));maxLTS=max(lts(startpt:stoppt)); minLTS=min(lts(startpt:stoppt));maxRHS=max(rhs(startpt:stoppt)); minRHS=min(rhs(startpt:stoppt));maxRVS=max(rvs(startpt:stoppt)); minRVS=min(rvs(startpt:stoppt));maxRTS=max(rts(startpt:stoppt)); minRTS=min(rts(startpt:stoppt));[minRHS, maxRHS] = axispad(minRHS,maxRHS);                          [minLHS, maxLHS] = axispad(minLHS,maxLHS);                          [minRVS, maxRVS] = axispad(minRVS,maxRVS);                          [minLVS, maxLVS] = axispad(minLVS,maxLVS);                          [minRTS, maxRTS] = axispad(minRTS,maxRTS);                          [minLTS, maxLTS] = axispad(minLTS,maxLTS);                          %%%%%%%%%%%% now for the individual button callbacks %%%%%%%%%%%%%%%%if strcmp( buttName, 'about')   aboutStr = {'Eyeballs3D -- Version 4.0,  May 2005';               ' ';               'Written by Jonathan Jacobs, Ph.D. (jxj24@cwru.edu)';               ' ';               'Ocular Motor Neurophysiology Lab (www.OMLAB.org)';               'VA Medical Center, Cleveland, OH';               ' ';               'Dept. of Neurology, School of Medicine';               'Case Western Reserve University';               ' ';               'All rights reserved.  All wrongs reversed.';               '(copyleft) 2002 - 2005';               ' '};   msgbox(aboutStr,'About ''Eyeballs''') elseif strcmp( buttName, 'rbzoom')   if get(gco,'value')==1      set(gco,'String','On')      figure(wfig)      zoom on    else      set(gco,'String','Off')      figure(wfig)      zoom off      % update all the damn sliders and text boxes; make sure all axes are equal      xlims=get(gca,'Xlim')*samp_freq;      set(start_sli,'Value', xlims(1))      ebAct3D('start_sli');      set(stop_sli,'Value', xlims(2))      ebAct3D('stop_sli');   end elseif findstr( buttName, 'resize')    if strcmp( buttName(8:9), 'eb')      if strcmp( buttName(11:13), 'sli') 		   eb_size = get(gco,'Value');			set(eb_size_txt,'String', num2str(eb_size,3));   %% 2?  or 3?		 elseif strcmp( buttName(11:13), 'txt')			eb_size = str2num(get(eb_size_txt,'String')); 			if isempty(eb_size) | (eb_size>1) | (eb_size<0.5)			   eb_size=get(eb_size_sli,'Value');				set(eb_size_txt,'String',num2str(eb_size,3));			end			  set(eb_size_sli, 'Value', eb_size);		end		windH = efig;		wscale = eb_size;		maxwidth = 570; maxheight = 264;		    elseif strcmp( buttName(8:9), 'wf')      if strcmp( buttName(11:13), 'sli') 		   wf_size = get(gco,'Value');			set(wf_size_txt,'String', num2str(wf_size,3));   %% 2?  or 3?		 elseif strcmp( buttName(11:13), 'txt')			wf_size = str2num(get(wf_size_txt,'String')); 			if isempty(wf_size) | (wf_size>1) | (wf_size<0.5)			   wf_size=get(wf_size_sli,'Value');				set(wf_size_txt,'String',num2str(wf_size,3));			end			  set(wf_size_sli, 'Value', wf_size);		end		windH = wfig;			wscale = wf_size;		maxwidth = 300;		maxheightlist = [280 540 670 810];      %% [255 507 640 780]		maxheight = maxheightlist(numplanes);  end      % get the position of the target window and find its center.   % we will resize around the center so window appears to shrink/grow   % equally in all directions.  neato.   wpos=get(windH,'Position');   x0 = wpos(1); y0 = wpos(2); width = wpos(3); height = wpos(4);   center = [x0+width/2, y0+height/2];   new_wid = maxwidth*wscale;   new_hgt = maxheight*wscale;   new_x0  = center(1)-new_wid/2;   new_y0  = center(2)-new_hgt/2;   set(windH,'Position',[new_x0, new_y0, new_wid, new_hgt])       % will we worry about the size of the text in the title, x/y labels?   % would be nice if smallifying windows below some thresh reduced the    % text to a more appropriate size.  ditto for embigulating them.   % the children of the waveform window are axes (from 1 to 7 depending   % on how many dimensions are being displayed).   if windH == wfig      if wscale > 0.85         titleFSize = 14; xyFSize = 12;        elseif wscale > 0.7          titleFSize = 12; xyFSize = 10;        elseif wscale > 0.6          titleFSize = 10; xyFSize = 8;        elseif wscale >= 0.5          titleFSize = 8; xyFSize = 6;      end            axlist = get(windH,'Children');      for ch=1:length(axlist)         titleH = get(axlist(ch),'Title');         %tfontsize = get(titleH,'FontSize');         set(titleH,'FontSize', titleFSize)         xlabelH = get(axlist(ch),'XLabel');         %xfontsize = get(xlabelH,'FontSize');         set(xlabelH,'FontSize', xyFSize)         ylabelH = get(axlist(ch),'YLabel');         %yfontsize = get(ylabelH,'FontSize');         set(ylabelH,'FontSize', xyFSize)      end   end   % and just for fun, we substitute a less complex eyeball if the   % window starts feeling crowded.   if windH == efig		ebmap = ones(128,3);      if wscale >= 0.8 			[z,y,x]=sphere(40);			ebmap(127:128,:) = zeros(2,3);			ebmap(119:126,1) = eyeColor(1);			ebmap(119:126,2) = eyeColor(2);			ebmap(119:126,3) = eyeColor(3);        elseif wscale >= 0.5 			[z,y,x]=sphere(24);			ebmap(126:128,:) = zeros(3,3);			ebmap(117:125,1) = eyeColor(1);			ebmap(117:125,2) = eyeColor(2);			ebmap(117:125,3) = eyeColor(3);      end      figure(efig)		temp = surf(x,y,z,x,'Visible','off');		cdata=get(temp,'CData');		delete(temp)		set(od,'XData',x, 'YData',y, 'ZData',z, 'CData',cdata)		set(os,'XData',x, 'YData',y, 'ZData',z, 'CData',cdata)		set(efig,'Colormap', ebmap)   end elseif findstr( buttName, 'speed')    % link the decimate and fps values    fps = str2num( get(fpsH,'string') );    dec = str2num( get(decimateH,'string') );        if strcmp(buttName(7),'d')       fps = fix(samp_freq/dec);       set(fpsH,'String',num2str(fps,'%d'));         elseif strcmp(buttName(7),'f')       dec = fix(samp_freq/fps);       set(decimateH,'String',num2str(dec,'%d'));        end   elseif strcmp( buttName, 'eyelight')   ouLightH = get(eyelightBH,'UserData');   odLightH = ouLightH(1);   osLightH = ouLightH(2);	if eyelight == 1	   axes(odSocket) 		odLightH = camlight(0,10);	   axes(osSocket) 		osLightH = camlight(0,10);		set(eyelightBH,'UserData', [odLightH osLightH])    else		delete(odLightH);		delete(osLightH);   end  	axes(overlay)  elseif strcmp( buttName, 'eyeliner')	if eyeliner == 0		set(os,'LineStyle','none')		set(od,'LineStyle','none')	 else		set(os,'LineStyle','-')		set(od,'LineStyle','-')	end elseif strcmp( buttName, 'start_txt')   startpt = str2num(get(start_txt,'String'));   if isempty(startpt), startpt=round(get(start_sli,'Value')); end   set(start_sli,'Value',startpt);   ebAct3D('start_sli') elseif strcmp( buttName, 'start_sli')   if startpt>=stoppt, startpt=stoppt-1; end   startpt = max(startpt,1);   startpt=fix(startpt);   set(start_sli,'Value',startpt);   set(start_txt,'String', num2str(startpt));   set(start_txt2,'String', num2str(startpt/samp_freq));   curpt = max(startpt,curpt);   ebAct3D('cur_sli')   if plotHOR	   set(wf_axLH,'Xlim',[startpt/samp_freq stoppt/samp_freq])	   set(wf_axRH,'Xlim',[startpt/samp_freq stoppt/samp_freq])	   if minLHS~=maxLHS, set(wf_axLH,'yLim',[minLHS maxLHS]); end	   if minRHS~=maxRHS, set(wf_axRH,'yLim',[minRHS maxRHS]); end	end   if plotVRT	   set(wf_axLV,'Xlim',[startpt/samp_freq stoppt/samp_freq])	   set(wf_axRV,'Xlim',[startpt/samp_freq stoppt/samp_freq])	   if minLVS~=maxLVS, set(wf_axLV,'yLim',[minLVS maxLVS]); end	   if minRVS~=maxRVS, set(wf_axRV,'yLim',[minRVS maxRVS]); end	end   if plotTOR	   set(wf_axLT,'Xlim',[startpt/samp_freq stoppt/samp_freq])	   set(wf_axRT,'Xlim',[startpt/samp_freq stoppt/samp_freq])	   if minLTS~=maxLTS, set(wf_axLT,'yLim',[minLTS maxLTS]); end	   if minRTS~=maxRTS, set(wf_axRT,'yLim',[minRTS maxRTS]); end	end elseif strcmp( buttName, 'stop_txt')   stoppt = str2num(get(stop_txt,'String'));   if isempty(stoppt), stoppt=round(get(stop_sli,'Value')); end   set(stop_sli,'Value',stoppt);   ebAct3D('stop_sli') elseif strcmp( buttName, 'stop_sli')   if stoppt<=startpt, stoppt=startpt+1; end   stoppt=min(stoppt,datlen);   stoppt=round(stoppt);   set(stop_sli,'Value',stoppt);   set(stop_txt,'String', num2str(stoppt));   set(stop_txt2,'String', num2str(stoppt/samp_freq));   curpt = min(stoppt,curpt);   ebAct3D('cur_sli')   if plotHOR	   set(wf_axLH,'Xlim',[startpt/samp_freq stoppt/samp_freq])	   set(wf_axRH,'Xlim',[startpt/samp_freq stoppt/samp_freq])	   if minLHS~=maxLHS, set(wf_axLH,'yLim',[minLHS maxLHS]); end	   if minRHS~=maxRHS, set(wf_axRH,'yLim',[minRHS maxRHS]); end	end   if plotVRT	   set(wf_axLV,'Xlim',[startpt/samp_freq stoppt/samp_freq])	   set(wf_axRV,'Xlim',[startpt/samp_freq stoppt/samp_freq])	   if minLVS~=maxLVS, set(wf_axLV,'yLim',[minLVS maxLVS]); end	   if minRVS~=maxRVS, set(wf_axRV,'yLim',[minRVS maxRVS]); end	end   if plotTOR	   set(wf_axLT,'Xlim',[startpt/samp_freq stoppt/samp_freq])	   set(wf_axRT,'Xlim',[startpt/samp_freq stoppt/samp_freq])	   if minLTS~=maxLTS, set(wf_axLT,'yLim',[minLTS maxLTS]); end	   if minRTS~=maxRTS, set(wf_axRT,'yLim',[minRTS maxRTS]); end	end elseif strcmp( buttName(1:3), 'cur')     %% 'cur_txt', 'cur_sli'   if strcmp( buttName(5:7), 'txt')      curpt = str2num(get(cur_txt,'String'));   end   if isempty(curpt), curpt=round(get(cur_sli,'Value')); end   if curpt<startpt, curpt=startpt; end   if curpt>stoppt,  curpt=stoppt; end   curpt=fix(curpt);   set(cur_sli,'Value', curpt );   set(cur_txt,'String', num2str(curpt));   set(cur_txt2,'String', num2str(curpt/samp_freq));   set(osSocket,'View',[lhs(curpt)+90 -lvs(curpt)]);   set(odSocket,'View',[rhs(curpt)+90 -rvs(curpt)]);   prev_tor(1)=get(osSocket,'UserData');   prev_tor(2)=get(odSocket,'UserData');   rotate( os,[1 0 0],     lts(curpt)-prev_tor(1) );   rotate( od,[1 0 0],     rts(curpt)-prev_tor(2) );   rotate( osMrkr,[1 0 0], lts(curpt)-prev_tor(1) );   rotate( odMrkr,[1 0 0], rts(curpt)-prev_tor(2) );   prev_tor = [lts(curpt) rts(curpt)];   set(osSocket,'UserData',prev_tor(1))   set(odSocket,'UserData',prev_tor(2))   ebAct3D('hvt_update')    elseif strcmp( buttName(1), 'f')   if strcmp( buttName(3:5), 'cur')      new_cur=str2num(get(cur_txt2,'string'))*samp_freq;      set(cur_txt,'String',num2str(new_cur));      ebAct3D('cur_txt')    elseif strcmp( buttName(3:6), 'stop')      new_stop=str2num(get(stop_txt2,'string'))*samp_freq;      set(stop_txt,'String',num2str(new_stop));      ebAct3D('stop_txt')    elseif strcmp( buttName(3:7), 'start')      new_start=str2num(get(start_txt2,'string'))*samp_freq;      set(start_txt,'String',num2str(new_start));      ebAct3D('start_txt')   end elseif strcmp( buttName, 'xy_setup')   xyplotenabled=get(plotXYh,'value');   if xyplotenabled      xyplotsettings('initialize')   end elseif strcmp( buttName, 'play!')   pbH = gco;   %if get(cur_sli,'Value') < get(stop_sli,'Value')   if get(pbH,'UserData') == 1      disp('Playback in progress. Please wait.')      return   end   set(pbH,'UserData',1)   % allocate space for the movie(s)   %rect = [245 7 96 96]; capture only OS   make_e_movie=get(e_movieBH,'Value');   if make_e_movie      numframes = length(startpt:playstep:stoppt);      e_movie=moviein(numframes,efig);      j=1;   end   make_wf_movie=get(wf_movieBH,'Value');   if make_wf_movie      numframes = length(startpt:playstep:stoppt);      wf_movie=moviein(numframes,wfig);      k=1;   end   % clear the torsions   prev_tor(1)=get(osSocket,'UserData');   prev_tor(2)=get(odSocket,'UserData');   rotate( os,[1 0 0],     prev_tor(1) );   rotate( od,[1 0 0],     prev_tor(2) );   rotate( osMrkr,[1 0 0], prev_tor(1) );   rotate( odMrkr,[1 0 0], prev_tor(2) );   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%   %%%%%%%   start of XY plot setup   %%%%%%%%%%   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%   if plotXY      % load the settings from the XYplot axis' 'UserData'  They were stored      % there by the 'Apply' or 'Done' commands in 'xyplotsettings.m'      % if you try to play w/o first initializing the xy settings, the xy init      % window will be called, and nothing can happen until it is dismissed.      temp=get(wf_axXY, 'Userdata');      xy_val=temp{1};		if ~iscell(xy_val)		   xyplotsettings('initialize')		   uiwait		   temp=get(wf_axXY, 'Userdata');		   xy_val=temp{1};		end      windowtitle  = xy_val{1};   xdata1       = xy_val{2};		xdata1vel    = xy_val{3};   xdata1acc    = xy_val{4};		xdata1label  = xy_val{5};   xdata1other  = xy_val{6};		ydata1       = xy_val{7};   ydata1vel    = xy_val{8};		ydata1acc    = xy_val{9};   ydata1label  = xy_val{10};  		xdata1other = xy_val{11};   xlowlim      = xy_val{12};		xhighlim     = xy_val{13};  ylowlim      = xy_val{14};      yhighlim     = xy_val{15};  line1color   = xy_val{16};		line1style   = xy_val{17};  head1color   = xy_val{18};		head1symbol  = xy_val{19};  history      = xy_val{20};		fplimh	    = xy_val{21};  fplimv       = xy_val{22};		fvlim        = xy_val{23};  samp_or_sec  = xy_val{24};		wt_locked    = xy_val{25};  xl_locked    = xy_val{26};	   yl_locked    = xy_val{27};  x_dat_str    = xy_val{28};		y_dat_str    = xy_val{29};		% set the color/style/symbol popup menu string		colorlist = ['r' 'y' 'g' 'b' 'c' 'm' 'w' 'k'];		stylelist = ['-' '--' ':' '-.'];		symbolist = ['o' 's' '^' 'x' '*' 'd' 'h'];      line1colorstr  = colorlist(line1color);      line1stylestr  = stylelist(line1style);      head1colorstr  = colorlist(head1color);      head1symbolstr = symbolist(head1symbol);            % If second word of x_data_str is 'other', the user selected data directly      % from the workspace, and should not be modified, just placed in 'xtemp'.      % Otherwise, use 'eval' to place the actual data into 'xtemp', which will       % be differentiated as needed, and the subarray as selected by the 'start'      % and 'stop' controls will be placed into 'xdata' for playback.      % 	The 's' appended to 'x_chan' turns e.g. 'lh' into 'lhs', which is the      % scaled and offset version of 'lh'.  (Don't do this for 'other' data.)      % Ditto for 'ydata'.       [x_chan, temp] = strtok(x_dat_str,','); x_deriv=temp(2:end);      if strcmp(x_deriv,'other')         % have to pull the same fugly trick as we did in 'xyplotsettings'         %(in the findstr(xybutton,'other') code) to create a temporary global         % variable, both here and in the base workspace, that will allow us to         % access the array specified in the 'other' control.         global ebtempresult         evalin('base','global ebtempresult')			evalin('base',['ebtempresult = ' x_chan ';'])			xtemp = ebtempresult;			clear global ebtempresult       else         eval(['xtemp = ' x_chan 's;'])			if x_deriv(1)=='v'				xtemp=d2pt(xtemp,2);			 elseif x_deriv(1)=='a'				xtemp=d2pt(xtemp,2); xtemp=d2pt(xtemp,2);			end		end	      [y_chan, temp] = strtok(y_dat_str,','); y_deriv=temp(2:end);      if strcmp(y_deriv,'other')         global ebtempresult         evalin('base','global ebtempresult')			evalin('base',['ebtempresult = ' y_chan ';'])			ytemp = ebtempresult;			clear global ebtempresult       else			eval(['ytemp = ' y_chan 's;'])			if y_deriv(1)=='v'				ytemp=d2pt(ytemp,2);			 elseif y_deriv(1)=='a'				ytemp=d2pt(ytemp,2); ytemp=d2pt(ytemp,2);			end		end		history = abs(str2num(history));		if samp_or_sec == 1                       % time		   timeshift = round(history*samp_freq);		 else                                     % samples		   timeshift = round(history);		end		xdata = xtemp(startpt:stoppt);   		ydata = ytemp(startpt:stoppt);   		frontpad = NaN * ones(timeshift,1);		ppdata_x = [frontpad; xdata];		ppdata_y = [frontpad; ydata];      % calculate the x,y axis limits.      % moved this to 'xyplotsettings'      %xmax=max(xdata); xmin=min(xdata);		%ymax=max(ydata); ymin=min(ydata);		%xrange = xmax-xmin;		%yrange = ymax-ymin;		%xmincalc = xmin - 0.1*xrange; xmaxcalc = xmax + 0.1*xrange;		%ymincalc = ymin - 0.1*yrange; ymaxcalc = ymax + 0.1*yrange;      % If any of the axis limits fields from xyplotsettings have manual entries      % use those.  Otherwise use the calculated limit(s)		%if isempty(str2num(xlowlim)),  xmin=xmincalc; else xmin=str2num(xlowlim);  end		%if isempty(str2num(xhighlim)), xmax=xmaxcalc; else xmax=str2num(xhighlim); end		%if isempty(str2num(ylowlim)),  ymin=ymincalc; else ymin=str2num(ylowlim);  end		%if isempty(str2num(yhighlim)), ymax=ymaxcalc; else ymax=str2num(yhighlim); end      %if xmin==xmax,xmin=xmin-eps;xmax=xmax+eps; end      %if ymin==ymax,ymin=ymin-eps;ymax=ymax+eps; end            xlowlim=str2num(xlowlim); xhighlim=str2num(xhighlim);      ylowlim=str2num(ylowlim); yhighlim=str2num(yhighlim);		%set(wf_axXY,'xlim',[xlowlim xhighlim],'ylim',[ylowlim yhighlim])				set(wf_dataXY,'Color',line1colorstr, 'LineStyle', line1stylestr)		set(wf_dataXY,'XData',[],'YData',[]) 		set(wf_overXY, 'Color',head1colorstr, 'Marker', head1symbolstr,... 		               'MarkerFaceColor',head1colorstr,'MarkerEdgeColor','w')      set(wf_overXY,'Xdata',[],'Ydata',[]);   		figure(wfig); hold on 		set(wf_axXY,'UserData',{xy_val,{ppdata_x ppdata_y} 1})       	end	   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%   %%%%%%%   end of XYplot setup   %%%%%%%%%%%%%   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%     t_betw_frames = playstep/samp_freq;   i = startpt;   % this is the animation loop.  it is inherently slow, thanks to the very   % time consuming call to 'drawnow.'  I suspect that there is nothing that   % will ever improve its performance.  best time between frames, even with   % 'live monitor' off is ~0.075 seconds for large eyeballs.     % (measured on dual GHz G4, ML7.01 (R14,SP1), OS X 10.3.7)   %profile on   a=1; p=0;   while i <= stoppt      stoppt=round(get(stop_sli,'Value'));  % can stop animation in the middle      tic;      set(osSocket,'View',[lhs(i)+90 -lvs(i)]);      set(odSocket,'View',[rhs(i)+90 -rvs(i)]);      if lts(i)			rotate( os,[1 0 0],     lts(i)-prev_tor(1) );			rotate( osMrkr,[1 0 0], lts(i)-prev_tor(1) );		end		if rts(i)			rotate( od,[1 0 0],     rts(i)-prev_tor(2) );			rotate( odMrkr,[1 0 0], rts(i)-prev_tor(2) );		end		prev_tor = [lts(i) rts(i)];       set(cur_sli,'Value', i);      set(cur_txt,'String', num2str(i));      set(cur_txt2,'String', num2str(i/samp_freq));      % get the eyeball frame      if make_e_movie,   drawnow; e_movie(:,j)=getframe(efig); j=j+1; end      % update the waveform window. (frippery)		% used to be a single call to 'ebAct3D('hvt_update')' but the recursive		% nature of that call adds a lot of extra overhead.  such is life.		i = get(cur_sli,'Value');		if livemonitor			xval = i/samp_freq;				   		   if plotHOR			   set(wf_overLH,'Xdata',xval);			   set(wf_overLH,'Ydata',lhs(i));			   set(wf_overRH,'Xdata',xval);			   set(wf_overRH,'Ydata',rhs(i));			end		   if plotVRT			   set(wf_overLV,'Xdata',xval);			   set(wf_overLV,'Ydata',lvs(i));			   set(wf_overRV,'Xdata',xval);			   set(wf_overRV,'Ydata',rvs(i));			end		   if plotTOR			   set(wf_overLT,'Xdata',xval);			   set(wf_overLT,'Ydata',lts(i));			   set(wf_overRT,'Xdata',xval);			   set(wf_overRT,'Ydata',rts(i));			end   		   if plotXY		      % we had to tack some NaN data onto the beginning of the		      % array (and shift it) so we can have some history to display.            ind=i-startpt+1;		      set(wf_dataXY,'Xdata',ppdata_x(ind:timeshift+ind));		      set(wf_dataXY,'Ydata',ppdata_y(ind:timeshift+ind));		      set(wf_overXY,'Xdata',ppdata_x(timeshift+ind));		      set(wf_overXY,'Ydata',ppdata_y(timeshift+ind));			end   		end      % get the waveform frame      if make_wf_movie, drawnow; wf_movie(:,k)=getframe(wfig); k=k+1; end      drawnow      t1(a)=toc; a=a+1;      %t1=toc;      time_to_pause = 1000*(t_betw_frames-t1);  %in milliseconds      if time_to_pause > 0         mypause(time_to_pause)         %p=p+1;      end      i = i + playstep;   end   %profile viewer   %keyboard   % eyes front, mister!   mypause(150)   set(osSocket,'View',[0+90 0]);   set(odSocket,'View',[0+90 0]);   set(osSocket,'UserData',0);   set(odSocket,'UserData',0);	rotate( os,[1 0 0],     -prev_tor(1) );	rotate( od,[1 0 0],     -prev_tor(2) );	rotate( osMrkr,[1 0 0], -prev_tor(1) );	rotate( odMrkr,[1 0 0], -prev_tor(2) );	drawnow      % clear the wform markers   if plotHOR, set(wf_overLH,'Ydata',NaN); set(wf_overRH,'Ydata',NaN); end   if plotVRT, set(wf_overRV,'Ydata',NaN); set(wf_overLV,'Ydata',NaN); end   if plotTOR, set(wf_overRT,'Ydata',NaN); set(wf_overLT,'Ydata',NaN); end   %%prev_tor = 0; % unneeded for 'play'?   	   % playback is over   set(pbH,'UserData',0)	old_dir=pwd;		% if user hit 'stop' button, the 'stop' slider is wrong.  Fix it.	set(stop_sli,'Value', str2num(get(stop_txt,'String')))      imageformats = {'jpeg','png','tiff','gif'};   imageformatstr = imageformats{imageformat};   % save the movie(s)   % if neither wf nor eye movies are selected, 'start' remains > 'stop'   start = 2; stop = 1;	if make_e_movie,  start = 1; which_movie{1} =  'e_movie';  end	if make_wf_movie, stop  = 2; which_movie{2} =  'wf_movie'; end	prompt{1} = 'Save the eyeball movie as:';	prompt{2} = 'Save the waveform movie as:';   for m = start:stop  %% if start>stop, nothing is executed	   [fn,pn]=uiputfile({'*.mov;*.avi;*.*'},prompt{m});	   if fn==0, return, end	   [fn, exten] = strtok(fn,'.');	   if pn		   %map=get(wfig,'colormap');		   tempmap = colormap;		   cd(pn)		   switch lower(moviemode(1))		    case 'q'		      moviename = [fn '.mov'];		      eval([ 'qtwrite(' which_movie{m} ', tempmap, moviename, ' ...		                '[fps/movie_speed, qtcompressor, spatialqual])' ]);          otherwise            % save the movie frames as individual images and use QuickTime            % to turn them into a real movie, not this AVI shit.            % First, make sure that we are writing frames to new folder				if make_stills					framefold = [fn '_frames'];					temp = dir; maxnum = 0;					foldname = framefold;  %% our inital & default condition					for i=1:length(temp)						% name already exists?  maybe more than one?  append a number to						% the name e.g. 'test_frames1', ... 'test_frames_10',...						% the created folder name will be one higher than the previous						% highest.  will NOT fill in gaps below highest number						tempname = temp(i).name;						if findstr(tempname, framefold)  % name DOES already exist							% look for appended number							num = str2num(tempname(find(isdigit(tempname))));							if isempty(num), num = 0; end							if num >= maxnum, maxnum = num+1; end							foldname = [framefold num2str(maxnum)];						 						 else  % name DOES NOT exist							 ;  % do nothing						end					end					mkdir(foldname); cd(foldname)											% write the individual frames.  We can use QuickTime Pro's nifty					% "Open Image Sequence..." to make a movie from these frames.						for i=1:numframes						  eval([ 'temp_frame = frame2im(' which_movie{m} '(i));' ]);						  temp_name = ['frame_' num2str(i) '.' imageformatstr];						  imwrite(temp_frame,temp_name,imageformatstr);						end					end            if make_avi		         eval([ 'movie2avi(' which_movie{m} ',fn,''colormap'', tempmap,' ...		                ' ''fps'', fps/movie_speed);' ]);            end		   end           %% switch lower(moviemode(1))		end              %% if pn      cd(old_dir)   end                 %% for m   figure(cfig)   elseif strcmp( buttName, 'hvt_update')   i = get(cur_sli,'Value');   if livemonitor		         if plotHOR	      set(wf_overLH,'Xdata',i/samp_freq);	      set(wf_overLH,'Ydata',lhs(i));	      set(wf_overRH,'Xdata',i/samp_freq);	      set(wf_overRH,'Ydata',rhs(i));	   end      if plotVRT	      set(wf_overLV,'Xdata',i/samp_freq);	      set(wf_overLV,'Ydata',lvs(i));	      set(wf_overRV,'Xdata',i/samp_freq);	      set(wf_overRV,'Ydata',rvs(i));	   end      if plotTOR	      set(wf_overLT,'Xdata',i/samp_freq);	      set(wf_overLT,'Ydata',lts(i));	      set(wf_overRT,'Xdata',i/samp_freq);	      set(wf_overRT,'Ydata',rts(i));	   end   		if plotXY			% we had to tack some NaN data onto the beginning of the			% array (and shift it) so we can have some history to display.			temp=get(wf_axXY, 'Userdata');			xy_val=temp{1};			played_yet=temp{3};			if ~played_yet, return; end						history      = xy_val{20};			samp_or_sec  = xy_val{21};         ppdata_x = temp{2}{1};         ppdata_y = temp{2}{2};                  if length(ppdata_x)<2, return; end         			history = abs(str2num(history));			if samp_or_sec == 1                       % time				timeshift = round(history*samp_freq);			 else                                     % samples				timeshift = round(history);			end			ind=i-startpt+1;			set(wf_dataXY,'Xdata',ppdata_x(ind:timeshift+ind));			set(wf_dataXY,'Ydata',ppdata_y(ind:timeshift+ind));			set(wf_overXY,'Xdata',ppdata_x(timeshift+ind));			set(wf_overXY,'Ydata',ppdata_y(timeshift+ind));		end   	end elseif strcmp( buttName, 'color')	eyeColor = uisetcolor;	if any(eyeColor)         % so we can use values containing zeros		ebmap = ones(128,3);		eb_size = get(eb_size_sli,'Value');		if eb_size >= 0.8			ebmap(127:128,:) = zeros(2,3);			ebmap(119:126,1) = eyeColor(1);			ebmap(119:126,2) = eyeColor(2);			ebmap(119:126,3) = eyeColor(3);		   		  elseif eb_size >= 0.5			ebmap(126:128,:) = zeros(3,3);			ebmap(117:125,1) = eyeColor(1);			ebmap(117:125,2) = eyeColor(2);			ebmap(117:125,3) = eyeColor(3);		end		set(od,'UserData',eyeColor);	   set(efig,'Colormap',ebmap);   end    elseif strcmp( buttName, 'crosshairs')   crossHstate = get(crossH,'value');   if crossHstate==0, newVis = 'off'; else newVis = 'on'; end   chLineH = get(crossH,'UserData');   set(chLineH(1),'Visible',newVis);   set(chLineH(2),'Visible',newVis);   set(chLineH(3),'Visible',newVis);   set(chLineH(4),'Visible',newVis);    elseif strcmp( buttName, 'tormrkr')   val = get(gco,'Value');   if val      set(osMrkr,'Visible','on');      set(odMrkr,'Visible','on');      %set(osMrkr,'MarkerEdgeColor',[1 0 0]);      %set(osMrkr,'MarkerFaceColor',[1 0 0]);      %set(odMrkr,'MarkerEdgeColor',[1 0 0]);      %set(odMrkr,'MarkerFaceColor',[1 0 0]);    else      set(osMrkr,'Visible','off');      set(odMrkr,'Visible','off');      %set(odMrkr,'MarkerEdgeColor','None');      %set(osMrkr,'MarkerEdgeColor','None');      %set(odMrkr,'MarkerFaceColor','None');      %set(osMrkr,'MarkerFaceColor','None');   end    elseif strcmp( buttName, 'wf_draw')   % why was 'wf_draw' called? (could be 'plot h/v/t/pp' checkbox   % or could be result of data scaling.  If it is checkbox call   % make sure that at least one checkbox remains checked.   caller=get(gco,'UserData');   value = get(plotVRTh,'value') | get(plotHORh,'value') | ...           get(plotTORh,'value') | get(plotXYh, 'value');         if ~value              % if user is turning off final checkbox      set(gco,'Value',1)  % you can't do that!      value = value + 1;      return   end      % get the window position.  we only care about the origin.   figure(wfig);   wfigpos = get(wfig,'Position');   % if there is pre-existing user data in the XY plot axis, retain it.   % we will restore it at the end of this section   % is this necessary?  'datscale' stores offset/scale values in the    % H,V,T (L&R) axes user data.  but do we want to save it?  hmmmm.   wf_userD = get(wfig,'UserData');   wH = wf_userD{2}; wf_axXY = wH(13);   xy_ax_userD = [];   if wf_axXY, xy_ax_userD = get(wf_axXY,'UserData'); end      clf      % num_ax, numplanes were calculated at the beginning of ebAct3D	if numplanes == 1	   wfigmax=[300 280];          %% 255	 elseif numplanes == 2	   wfigmax=[300 540];          %% 507	 elseif numplanes == 3 	   wfigmax=[300 670];          %% 640	 elseif numplanes == 4	   wfigmax=[300 810];          %% 780	 else	   return  	end	% since wfig window can be resized, we want to use its CENTER	% (which is saved as 'wf_center' and was used in eb3d to set wfig pos)	% Then we need to calculate new x,y origins based on wfig's center and scale   wf_size = get(wf_size_sli,'Value');   maxwidth = wfigmax(1); maxheight = wfigmax(2);   x0    = wfigpos(1); y0     = wfigpos(2);    width = wfigpos(3); height = wfigpos(4);   center = [x0+width/2, y0+height/2];   new_wid = maxwidth*wf_size;   new_hgt = maxheight*wf_size;   new_x0 = center(1)-new_wid/2;   new_y0 = center(2)-new_hgt/2;	   set(wfig,'Position', [new_x0, new_y0, new_wid, new_hgt],'Color',[0.2 0.2 0.2]);      ax_units = 'Normalized';   % 'yorig' is y origin for each axis   % majick numbers -- determined by trial and error.   yorig{7} = [0.875 0.765 0.625 0.515 0.375 0.265 0.045];   yorig{6} = [0.85 0.71 0.525 0.385 0.20 0.06];   yorig{5} = [0.83 0.68 0.48 0.33 0.055];   yorig{4} = [0.77 0.56 0.29 0.08];   yorig{3} = [0.74 0.49 0.07];   yorig{2} = [0.53 0.13];   yorig{1} = [0.15];      % 'ht' is height of each axis; 'ppht' is the height of the pp axis   % majick numbers -- determined by trial and error.   ht{7} = 0.09;  ppht{7} = 0.15;   ht{6} = 0.11;     ht{5} = 0.13;  ppht{5} = 0.185;   ht{4} = 0.18;   ht{3} = 0.20;  ppht{3} = 0.30;   ht{2} = 0.35;                  ppht{1} = 0.75;      xorig = 0.18; wid = 0.74;   plotSTM = get(plotSTMh,'value');   % start drawing the desired axes in the wf window.    sub_p = 1; 	 wf_ax = zeros(3,2);   wf_over = zeros(3,2);   chanstr   = {'rhs', 'lhs'; 'rvs', 'lvs'; 'rts', 'lts'};   titlestr  = {'Horizontal'; 'Vertical'; 'Torsional'};   ylabelstr = {['RH (' degstr ')'],['LH (' degstr ')'];...                ['RV (' degstr ')'],['LV (' degstr ')'];...                ['RT (' degstr ')'],['LT (' degstr ')'] };                	minval    = [minRHS minLHS; minRVS minLVS; minRTS minLTS];	maxval    = [maxRHS maxLHS; maxRVS maxLVS; maxRTS maxLTS];	scale     = [rh_scale  lh_scale;  rv_scale  lv_scale;  rt_scale  lt_scale];	offset    = [rh_offset lh_offset; rv_offset lv_offset; rt_offset lt_offset];		if wf_size > 0.85		titleFSize = 14; xyFSize = 12;	  elseif wf_size > 0.7 		titleFSize = 12; xyFSize = 10;	  elseif wf_size > 0.6 		titleFSize = 10; xyFSize = 8;	  elseif wf_size >= 0.5 		titleFSize = 8; xyFSize = 6;	end	plotAX(1) = plotHOR; plotAX(2) = plotVRT; plotAX(3) = plotTOR;	for x=1:3		if plotAX(x)			wf_ax(x,1) = axes('Position',[xorig yorig{num_ax}(sub_p) wid ht{num_ax}]);			if plotSTM, plot(t,sv,'r'); hold on; end			eval([ 'plot(t,' chanstr{x,1} ',''c''); hold on; axis tight; grid' ]);			title(titlestr{x},  'FontSize',titleFSize)			ylabel(ylabelstr{x,1},'FontSize',xyFSize)			wf_over(x,1) = plot(NaN, NaN,'wo');			set(wf_over(x,1),'MarkerSize',6,'EraseMode','xor','MarkerFaceColor','r')			if minval(x,1)~=maxval(x,1)			   set(wf_ax(x,1),'yLim',[minval(x,1) maxval(x,1)]);			end			%set(wf_ax(x,1),'UserData',{scale(x,1), offset(x,1) });			set(wf_ax(x,1),'xlim',[startpt/samp_freq stoppt/samp_freq])			set(wf_ax(x,1),'xticklabel','')			set(wf_ax(x,1),'Units',ax_units,'Color','k')			sub_p=sub_p+1;				wf_ax(x,2) = axes('Position',[xorig yorig{num_ax}(sub_p) wid ht{num_ax}]);			if plotSTM, plot(t,sv,'r'); hold on; end			eval([ 'plot(t,' chanstr{x,2} ',''y''); hold on; axis tight; grid' ]);			ylabel(ylabelstr{x,2},'FontSize',xyFSize)			wf_over(x,2) = plot(NaN, NaN,'wo');			set(wf_over(x,2),'MarkerSize',6,'EraseMode','xor','MarkerFaceColor','r')			if minval(x,2)~=maxval(x,2)			   set(wf_ax(x,2),'yLim',[minval(x,2) maxval(x,2)]);			end			%set(wf_ax(x,2),'UserData',{scale(x,2), offset(x,2) });			set(wf_ax(x,2),'xlim',[startpt/samp_freq stoppt/samp_freq])			set(wf_ax(x,2),'Units',ax_units,'Color','k')			sub_p=sub_p+1;		end	end		wf_axRH=wf_ax(1,1);      wf_axRV=wf_ax(2,1);      wf_axRT=wf_ax(3,1);	wf_axLH=wf_ax(1,2);      wf_axLV=wf_ax(2,2);      wf_axLT=wf_ax(3,2);	wf_overRH=wf_over(1,1);  wf_overRV=wf_over(2,1);  wf_overRT=wf_over(3,1); 	wf_overLH=wf_over(1,2);  wf_overLV=wf_over(2,2);  wf_overLT=wf_over(3,2);	   % add the xlabel to the final (non XY) axis   if num_ax>1,xlabel('Time (seconds)','FontSize',xyFSize); end   % draw the XY axis   wf_axXY = 0; wf_dataXY = 0; wf_overXY = 0;   if plotXY      % create axis w/appropriate labels      % create empty plot for ppl data to be drawn into      wf_axXY = axes('Position',[xorig yorig{num_ax}(sub_p) wid ppht{num_ax}]);      box; hold on  		wf_dataXY = plot(NaN, NaN, 'g');  		wf_overXY = plot(NaN, NaN, 'wo');		%set(wf_dataXY,'EraseMode','xor') %%%		set(wf_overXY,'MarkerSize',6,'EraseMode','xor','MarkerFaceColor','r')		title('XY plot','FontSize',titleFSize)		xlabel('X units','FontSize',xyFSize)		ylabel('Y units','FontSize',xyFSize)		set(wf_axXY,'Units',ax_units, 'color','k')		set(wf_axXY,'UserData',{0,0,0})   end   wH = [wf_axLH wf_overLH wf_axLV wf_overLV wf_axLT wf_overLT,...         wf_axRH wf_overRH wf_axRV wf_overRV wf_axRT wf_overRT,...         wf_axXY wf_dataXY wf_overXY];   set(wfig,'UserData',{planes,wH,{offset scale},1});   %% 1: wf_ax_inited      % does updated wf window still have XY plot axis? If so, restore old user data.   if wf_axXY      if ~isempty(xy_ax_userD)         set(wf_axXY,'UserData',xy_ax_userD);      end      end      % if called from 'datscale' make the scaling window the foremost one.   % otherwise bring the controls window to the front   if strcmp(caller,'ds')      figure(sfig)    else      figure(cfig)   end elseif strcmp( buttName, 'load_data')   % button already called 'ebdataload' which simply contains the name of    % preferred method to load data (first clearing out the previous data).   % Now we verify that it is valid data.  Then must update settings of   % various controls to reflect the properties of the new data.	if noHOR      set(plotHORh,'Enable', 'off');  set(plotHORh,'Value',0)    else      set(plotHORh,'Enable','on')   end	if noVRT      set(plotVRTh,'Enable', 'off');  set(plotVRTh,'Value',0)    else      set(plotVRTh,'Enable','on')   end	if noTOR      set(plotTORh,'Enable', 'off');  set(plotTORh,'Value',0)    else      set(plotTORh,'Enable','on')   end   set(start_sli, 'Max',    datlen)   set(cur_sli,   'Max',    datlen)   set(stop_sli,  'Max',    datlen)   set(stop_sli,  'Value',  datlen)   set(stop_txt,  'String', num2str(datlen))   set(stop_txt2, 'String', num2str(datlen/samp_freq))   ebAct3D('wf_draw')          elseif strcmp( buttName, 'movieprefs')   %create a settings window   [movPrefs] = movieprefs(movPrefsBH,playstep);   set(movPrefsBH,'UserData',movPrefs)    elseif strcmp( buttName, 'done!')   cur_dir=pwd;   cd(findomprefs)   efigpos = get(efig,'Position');   cfigpos = get(cfig,'Position');   wfigpos = get(wfig,'Position');   wf_size = get(wf_size_sli,'Value');   eb_size = get(eb_size_sli,'Value');   eyeColor = get(od,'UserData');   wf_center = [ wfigpos(1)+wfigpos(3)/2, wfigpos(2)+wfigpos(4)/2 ];   % get the latest movie making preferences   movtemp=get(movPrefsBH,'UserData');   qtcompressor = movtemp{1};   spatialqual  = movtemp{2};   makeqtmovie  = movtemp{3};   imageformat  = movtemp{4};   movie_speed  = movtemp{5};   make_avi     = movtemp{6};   make_stills  = movtemp{7};      save ebPrefs.mat eyeColor efigpos cfigpos wfigpos wf_center ...        qtcompressor spatialqual makeqtmovie imageformat ...        movie_speed make_avi make_stills eb_size wf_size ...        eyeliner eyelight   eval('cd(cur_dir)','')   uiresume   eval('delete(efig)','')   eval('delete(cfig)','')   eval('delete(wfig)','')   eval('delete(mfig)','')   eval('delete(sfig)','')   eval('delete(xyfig)','')end  % if strcmp( buttName ...%*********************************************************************% movieprefs:  a private function in ebAct3D.% Written by:  Jonathan Jacobs%              April 2002 - January 2005 (last mod: 01/19/05) function [movPrefs] = movieprefs(movPrefsBH,playstep)global samp_freqcfig = -1; mfig = -1;wl = get(0,'Children');for i = 1:length(wl)   if strcmp(get(wl(i),'Name'),'Eye Monitor Control'), cfig=wl(i); end   if strcmp(get(wl(i),'Name'),'Movie Prefs'),         mfig=wl(i); endendcomp=computer;vers=version;if comp(1)=='M' & vers(1)=='5'   qt_available = 'on';    qt_flag = 1;   avi_available = 'off';  avi_flag = 0;  else   qt_available = 'off';   qt_flag = 0;   avi_available = 'on';   avi_flag = 1;endif mfig < 0   parent_w_pos = get(cfig,'Position');   mfig_ht = 320;   mfig=figure('Position',[parent_w_pos(1)+180 parent_w_pos(2)-70 280 mfig_ht],...               'Resize','off', 'Menubar', 'None', ...               'Name','Movie Prefs','NumberTitle','off' );   movtemp=get(movPrefsBH,'UserData');   qtcompressor = movtemp{1};   spatialqual  = movtemp{2};   makeqtmovie  = movtemp{3};   imageformat  = movtemp{4};   movie_speed  = movtemp{5};   make_avi     = movtemp{6};   make_stills  = movtemp{7};   ypos = mfig_ht;   % create the controls	uicontrol(mfig, 'Style', 'frame','Units', 'pixels',...	   'BackgroundColor',[0.25 0.25 0.25],'Position', [2 ypos-110 276 96]);	ypos = ypos-40;   makeqtH = uicontrol('Style','checkbox','Units','pixels',...	   'Position',[10 ypos-3 140 25],...	   'Tooltip','Make a QuickTime movie',...	   'String','Make a QuickTime movie',...	   'HorizontalAlignment', 'center',...	   'Enable',qt_available,...	   'Value', (makeqtmovie & qt_flag),... 	   'Callback',['']);	ypos = ypos-30;	uicontrol(mfig, 'Style', 'text',...	   'Position', [20 ypos 120 20], 'String', 'QT codec');   compressH = uicontrol('Style','popup','Units','pixels',...	   'Position',[145 ypos-3 120 25],...	   'String','video|jpeg|animation',...	   'Tooltip','Choose the QT codec',...	   'Enable',qt_available,...	   'HorizontalAlignment', 'center',...	   'Value', qtcompressor,... 	   'Callback',['']);	ypos = ypos-30;	uicontrol(mfig, 'Style', 'text',...	   'Position', [20 ypos 120 20], 'String', 'Quality');   spatqualH = uicontrol('Style','popup','Units','pixels',...	   'Position',[145 ypos-3 120 25],...	   'String','min|low|normal|high|max|lossless',...	   'Tooltip','Set the spatial quality',...	   'HorizontalAlignment', 'center',...	   'Enable',qt_available,...	   'Value', spatialqual,... 	   'Callback',['']);	uicontrol(mfig, 'Style', 'frame','Units', 'pixels',...	   'BackgroundColor',[0.25 0.25 0.25],'Position', [2 ypos-49 276 35]);	ypos = ypos-40;   makeaviH = uicontrol('Style','checkbox','Units','pixels',...	   'Position',[10 ypos-3 130 25],...	   'Tooltip','Make an AVI movie',...	   'String','Make an AVI movie',...	   'HorizontalAlignment', 'center',...	   'Enable',avi_available,...	   'Value', make_avi,... 	   'Callback',['']);	uicontrol(mfig, 'Style', 'frame','Units', 'pixels',...	   'BackgroundColor',[0.25 0.25 0.25],'Position', [2 ypos-80 276 66]);	ypos = ypos-40;   makestillsH = uicontrol('Style','checkbox','Units','pixels',...	   'Position',[10 ypos-3 130 25],...	   'Tooltip','Make a series of still frames',...	   'String','Make a series of images (Use QuickTime Pro to combine)',...	   'HorizontalAlignment', 'center',...	   'Value', make_stills,... 	   'Callback',['']);	ypos = ypos-30;	uicontrol(mfig, 'Style', 'text',...	   'Position', [20 ypos 120 20], 'String', 'Still Image Format');   imageformatH = uicontrol('Style','popup','Units','pixels',...	   'Position',[145 ypos-3 120 25],...	   'String','jpeg|png|tiff|gif',...	   'Tooltip','Choose the format for image frames',...	   'HorizontalAlignment', 'center',...	   'Value', imageformat,... 	   'Callback',['']);	uicontrol(mfig, 'Style', 'frame','Units', 'pixels',...	   'BackgroundColor',[0.25 0.25 0.25],'Position', [2 ypos-80 276 66]);	ypos = ypos-40;	uicontrol(mfig, 'Style', 'text',...	   'Position', [10 ypos 110 20], 'String', 'Movie Speed');	moviespeedH = uicontrol(mfig, 'Style', 'edit',...		'Position', [125 ypos 30 20],...		'BackGroundColor','magenta','ForeGroundColor','white',...		'Tooltip','Duration of AVI or QuickTime movie will be ''x'' times real-time',...		'String', num2str(movie_speed), 'Callback', [''] );	ypos = ypos-30;	uicontrol(mfig, 'Style', 'text',...	   'Position', [10 ypos 110 20], 'String', 'Effective FPS');	fpsH = uicontrol(mfig, 'Style', 'text',...		'Position', [125 ypos 30 20],...		'BackGroundColor','magenta','ForeGroundColor','white',...		'Tooltip','Speed (frames/sec) of AVI or QuickTime movie',...		'String', num2str((samp_freq/playstep)*movie_speed), 'Callback', [''] );   doneBH = uicontrol(mfig, 'Style', 'Pushbutton',...      'Position', [220 5 50 20],'UserData',0,...      'Tooltip','Close this window','String', 'Done',...      'Callback', ['uiresume'] ); else   return end% 'uiwait' will cause the function to wait here until a 'uiresume' is% executed. 'uiresume' is therefore the command issued by the 'done' callbackuiwaitqtcompressor = get(compressH,'Value');spatialqual  = get(spatqualH,'Value');makeqtmovie  = get(makeqtH,'Value');imageformat  = get(imageformatH,'Value');movie_speed  = str2num(get(moviespeedH,'String'));make_avi     = get(makeaviH,'Value');make_stills  = get(makestillsH,'Value');movPrefs = {qtcompressor, spatialqual, makeqtmovie, ...              imageformat, movie_speed, make_avi make_stills };set(movPrefsBH,'UserData',movPrefs)              close(mfig)%**************************************************************************% mypause.m: a true pause function for delays under a second% Usage: mypause(delay)% where delay is the desired time in milliseconds% NOTE: accuracy is generally good within about 5 ms% Written by:  Jonathan Jacobs%              October 1999  (last mod: 10/19/99)function mypause(delay)diff = 0;tic;while diff*1000 < (delay-0.25)   diff = toc;end