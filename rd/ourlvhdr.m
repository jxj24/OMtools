% ourlvhdr.m: reads the header for LabVIEW files generated by our computer% this is a mess, because it has evolved clumsily with no coordination% several people who have not communicated with each other before making% changes.% Written by:% Jonathan Jacobs     01/02   Created%% Modified by:% Jonathan Jacobs  03/17/03   Changed f4 to read in 6 bytes, rather than 5, %                             and deleted the fseek(1) that follows.  This%                             will allow for more than 99,999 samples to be%                             read in.% King Yi          04/08/11   Modified code to read in more LabVIEW scaling%                             values than in version 1.4.  The code definitely%                             needs to be rewritten.% we have already read in the first 20 characters.  They contain part of the% scale values that LabVIEW used when the data was acquired.test_str=fread(fid,500,'uchar')'; % Read in all header infofseek(fid,-500,'cof');  % go back to starting point (after first 20 characters are read in)test_str=char(test_str);index_v = max(strfind(test_str,'.vrg'));check_ver = str2double(test_str(index_v+4:end));if check_ver > 1.4    f1a = fread(fid,80,'uchar'); % expanded to 40 to 100 (20 + 80) for version 1.5else    f1a = fread(fid,20,'uchar'); % Version 1.4 or below endf1astr = char(f1a');fseek(fid,1,'cof');f2 = fread(fid,80,'uchar');temp = char(f2');if strcmp(temp(1:3),'___')   comments = rot13(temp(4:end)); else   comments = temp;endfseek(fid,1,'cof');f3 = fread(fid,60,'uchar');chnlstr = char(f3');chan_count = length(strfind(chnlstr,','))+1;fseek(fid,1,'cof');f4 = fread(fid,6,'uchar');points = str2double(char(f4'));%fseek(fid,1,'cof');f5 = fread(fid,4,'uchar');samp_freq = str2double(char(f5'));fseek(fid,1,'cof');f6 = fread(fid,35,'uchar');calib = char(char(f6'));temp = fread(fid,10,'uchar');char(temp);tempstr = char(char(temp'));init_time = str2double(tempstr);f6aa = fread(fid,50,'uchar');stimstr = char(char(f6aa'));f6a = fread(fid,5,'uchar');vers = str2double(char(f6a'));if isempty(vers)   vers = 1.0;endif vers >= 1.2   scaleval=str2double(f1str);endif vers == 1.3   [vpixx_stim,temp]=strtok(f1astr,',');   verge_stim = temp(2:end); elseif vers >= 1.4   scaleval=str2num([f1str f1astr]); %#ok<ST2NM> %s2d errors out on NaNs!   [vpixx_stim,temp]=strtok(stimstr,',');   verge_stim = temp(2:end); else   vpixx_stim = 'n/a';   verge_stim = 'n/a';end% new header stuff.  If we are using the OLD header% we will have to rewind the file 10 bytes (9+1 bytes)fseek(fid,1,'cof') ;f7 = fread(fid,9,'uchar') ;indic = char(f7') ;new_flag = strcmp(indic,'AO_PARAMS') ;only_ai_flag = strcmp(indic,'ONLY_ANIN') ;clear indicif (new_flag)   fseek(fid,1,'cof') ;   f8 = fread(fid,6,'uchar') ;   ao_smpf = str2double(char(f8')) ;   clear f8   fseek(fid,1,'cof') ;   f9 = fread(fid,6,'uchar') ;   n_ao_pts = str2double(char(f9')) ;   clear f9   fseek(fid,1,'cof') ;   f10 = fread(fid,2,'uchar') ;   n_int_arrays = str2double(char(f10')) ;   clear f10   fseek(fid,1,'cof') ;   f11 = fread(fid,40,'uchar') ;   ch_labels = char(f11') ;   clear f11   ch_lab_temp = lower(ch_labels) ;elseif (only_ai_flag)   n_int_arrays = 0 ;   ao_smpf = 0 ;   n_ao_pts = 0 ;   fseek(fid,1,'cof') ;   f11 = fread(fid,40,'uchar') ;   ch_labels = char(f11') ;   clear f11   ch_lab_temp = lower(ch_labels) ;else   % the is kinda clever, actually.  We calculate the size of the   % internal arrays by learning the length of the file, the length    % of the data and where we are in the file at the moment.   fseek(fid,-10,'cof') ;   ao_smpf = 100 ;   n_int_arrays = 6 ;   currentpos = ftell(fid);   fseek(fid,0,'eof');   eofpos = ftell(fid);   fseek(fid,currentpos,'bof');   datalen = chan_count*points*2;   % '*2' because data is 'short' (16 bits)   n_ao_pts = (eofpos-datalen-currentpos)/(n_int_arrays*4); % '*4' = 'long'end   