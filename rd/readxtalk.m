% readxtalk.m: load in the crosstalk corrections from the file corresponding% to the data currently being loaded.  The XT File will have name of data file% and '.xt' extension.% written by: Jonathan Jacobs%             March 2004  (last mod: 03/09/04)function [out, xt_err_flag] = readxtalk(filename)global enviroGxt_err_flag = 0;out = zeros(1,8);doXTalkRmvl = enviroG(7);shortname = filename( 1:find(filename=='.')-1);uscore = strfind(shortname,'_');if isempty(uscore)    xt_file = [shortname(1:3) '.xt'];else    xt_file = [shortname(1:uscore-1) '.xt'];end%disp( 'Looking for crosstalk file. ')if ~doXTalkRmvl    disp('  *** Crosstalk correction will NOT be applied ***')    xt_err_flag = 1;    returnelse    disp( ['Searching ' xt_file ' for crosstalk-removal info. ' ] )endfid = fopen(xt_file,'r');if fid == -1    xt_err_flag = 1;    disp([ sprintf('\b') ' ** None found ** '])    %disp(['  <<It must be in the same directory as ' filename '.>>'])    return;endxt_text = fread(fid);xt_text = char(xt_text');fclose(fid);%chName = [];isEOF = 0; %isEmptyLine = 0;while ~isEOF    [topline, xt_text, isEmptyLine, isEOF] = getnextl(xt_text);        if isEOF, return; end  %% 'return' ends right here. 'break' would jump out of loop        if ~isEmptyLine        [wordlist, ~] = procline(topline);        xtChan = wordlist(1,:);    else        xtChan = '';    end        switch lower(deblank(xtChan))        case {'rh'}            %rh_rvpos = 0.0; rh_rvneg = 0.0;            pos1 = strfind(topline,'+rv:');            temp = strtok(topline(pos1+4:end));            rh_rvpos = str2double(temp);            out(1) = rh_rvpos;                        neg1 = strfind(topline,'-rv:');            temp = strtok(topline(neg1+4:end));            rh_rvneg = str2double(temp);            disp(['   rh    +rv: ' num2str(rh_rvpos) '   -rv: ' num2str(rh_rvneg)])            out(2) = rh_rvneg;                    case {'lh'}            %lh_lvpos = 0.0; lh_lvneg = 0.0;            pos1 = strfind(topline,'+lv:');            temp = strtok(topline(pos1+4:end));            lh_lvpos = str2double(temp);            out(3) = lh_lvpos;                        neg1 = strfind(topline,'-lv:');            temp = strtok(topline(neg1+4:end));            lh_lvneg = str2double(temp);            disp(['   lh    +lv: ' num2str(lh_lvpos) '   -lv: ' num2str(lh_lvneg)])            out(4) = lh_lvneg;                    case {'rv'}            %rv_rhpos = 0.0; rv_rhneg = 0.0;            pos1 = strfind(topline,'+rh:');            temp = strtok(topline(pos1+4:end));            rv_rhpos = str2double(temp);            out(5) = rv_rhpos;                        neg1 = strfind(topline,'-rh:');            temp = strtok(topline(neg1+4:end));            rv_rhneg = str2double(temp);            disp(['   rv    +rh: ' num2str(rv_rhpos) '   -rh: ' num2str(rv_rhneg)])            out(6) = rv_rhneg;                    case {'lv'}            %lv_lhpos = 0.0; lv_lhneg = 0.0;            pos1 = strfind(topline,'+lh:');            temp = strtok(topline(pos1+4:end));            lv_lhpos = str2double(temp);            out(7) = lv_lhpos;                        neg1 = strfind(topline,'-lh:');            temp = strtok(topline(neg1+4:end));            lv_lhneg = str2double(temp);            disp(['   lv    +lh: ' num2str(lv_lhpos) '   -lh: ' num2str(lv_lhneg)])            out(8) = lv_lhneg;                    otherwise            %disp(['unknown channel name: ' xtChan])    end    end% we'd use this code if 'isEOF' test used 'break' instead of 'return'%out = [rh_rvpos, rh_rvneg, lh_lvpos, lh_lvneg, ...%       rv_rhpos, rv_rhneg, lv_lhpos, lv_lhneg ];