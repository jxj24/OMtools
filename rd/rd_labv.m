% rd_labv.m:  Read in 'labview' format files.  Multiple files can% be read in and their data will be stored in their own columns.% written by:  Jonathan Jacobs (some parts based on code by Vallabh Das%                                                         & Jeff Somers)%              March 1998 - January 2004  (last mod: 01/26/04)% 01/30/03: added line "clear newdata" to restore ability to load%           multiple datasets% 01/26/04: moved the reading and applying of bias file to 'applybias'%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%function data = rd_labv(pathname,filename,adjbiasvals)% Here's an interesting tidbit: LabVIEW writes data in% 'big-endian' format for BOTH Mac and DOS systems.fid = fopen([pathname filename], 'r', 'b');   % big-endian% in old format, 1st 20 chars are filename that contains coil cal vals% but in our format the 1st 40 chars contain the LV scale valsf1 = fread(fid,20,'uchar');f1str = char(f1');% will read num chan, etc from existing header.range = 100; % default valuetemp=strtok(f1str,':\');  %% f1str contains the file name, thereforeif length(temp)==1        %% the file is from the coil system   %disp('their header')   theirlvhdrelse   %disp('our header')   ourlvhdrend%samp_freq  was read in by ourlvhdr or theirlvhdr% load the data arrays% we will jump to the END of the file and rewind back% to the beginning of the data since we know how many points% to expect.  (the '*2' is because 'short' is 16 bits or 2 bytes)chan_count = length(strfind(chnlstr,','))+1; %#ok<NODEF> created by ourlvhdrfseek(fid, -chan_count*points*2, 'eof');[in_arr,~] = fread(fid,[chan_count,inf],'short');in_arr = in_arr';fclose(fid);chnlstr2 = chnlstr;chnlstr2( strfind(chnlstr2,',') ) = ' ';% sanity check: do the channel names in the file header match the% channel names in the adjbias file?i=1;while ~all(isspace(chnlstr))   [temp,chnlstr]=strtok(chnlstr,','); %#ok<STTOK>   temp=deblank(temp);   %hdrChanName{i}=char(temp);   if ~strcmp(char(temp),char(adjbiasvals.chName{i}))      error('Header channels do not match biasfile channels!')   end   i=i+1;end% multiply by calibration factornewdata = NaN(length(in_arr), chan_count);if vers == 1.1   % do our simple en masse scaling   % the '300' applies IF the LabVIEW Channel Wizard   % is set up with  scaling: x30   scarr = in_arr * (300/65536);     %convert to degs   newdata = scarr;elseif vers >= 1.2   for jj = 1:chan_count      newdata(:,jj) = in_arr(:,jj) * (scaleval(jj)*10)/65536;   endelse   % version 1.0, (i.e. taken w/ the coil system)   % convert to degs   % do individual calibrations   scarr = in_arr * (range/65536);     %'range' comes from 'theirlvhdr.m'   % apply the calibration   for k = 1:chan_count      newdata(:,k) = scarr(:,k) .* calib(k);   endend% creating a time array%t = (0:points-1)/samp_freq; t = t';commentstr = comments(end,:); %#ok<IDISVAR,NODEF> creted by ourlvhdr%commentstr = nameclean(commentstr);[dat_len, ~] = size( newdata );if ~strcmpi(deblank(vpixx_stim),'no.vpx')   disp( ['VPixx stim:         ' vpixx_stim] );endif ~strcmpi(deblank(verge_stim),'no.vrg')   disp( ['vergence stim:      ' verge_stim] );enddisp( ['Channels found:     ' chnlstr2] );disp( ['Comments:           ' commentstr] );disp( ['Samples found:      ' num2str(dat_len)] );disp( ['Sampling frequency: ' num2str(samp_freq) 'Hz'] );disp( ['Record duration:    ' num2str(dat_len/samp_freq) ' seconds'] );data.newdata   = newdata;data.samp_freq = samp_freq;data.comments  = commentstr;% return to RD