% rd_labv.m:  Read in 'labview' format files.  Multiple files can% be read in and their data will be stored in their own columns.% written by:  Jonathan Jacobs (some parts based on code by Vallabh Das%                                                         & Jeff Somers)%              March 1998 - January 2004  (last mod: 01/26/04)% 01/30/03: added line "clear newdata" to restore ability to load%           multiple datasets% 01/26/04: moved the reading and applying of bias file to 'applybias'%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%doScaling = enviroG(3);% open the file and read the header information[comp, maxsize] = computer;% Here's an interesting tidbit: LabVIEW writes data in% 'big-endian' format for BOTH Mac and DOS systems.fid = fopen([pathname filename], 'r', 'b');   % big-endian% l_files = l_files + 1;% total_files = r_files + a_files + b_files...%    + o_files + x_files + l_files;% in old format, 1st 20 chars are filename that contains coil cal vals% but in our format the 1st 40 chars contain the LV scale valsf1 = fread(fid,20,'uchar');f1str = char(f1');% will read num chan, etc from existing header.range = 100; % default valuetemp=strtok(f1str,':\');  %% f1str contains the file name, thereforeif length(temp)==1        %% the file is from the coil system   %disp('their header')   theirlvhdrelse   %disp('our header')   ourlvhdrend%samp_freq  was read in by ourlvhdr or theirlvhdr% load the data arrays% we will jump to the END of the file and rewind back% to the beginning of the data since we know how many points% to expect.  (the '*2' is because 'short' is 16 bits or 2 bytes)chan_count = length(strfind(chnlstr,','))+1;fseek(fid, -chan_count*points*2, 'eof');[in_arr,numbytes] = fread(fid,[chan_count,inf],'short');in_arr = in_arr';fclose(fid);getbiaschnlstr2 = chnlstr;chnlstr2( findstr(chnlstr2,',') ) = ' ';% Make the arrays of possible header channel names. chanName(ii,:)hdrChanName=[];i=1;%chnlstr2 = upper(chnlstr);while ~all(isspace(chnlstr))   [temp,chnlstr]=strtok(chnlstr,',');   temp=deblank(temp);   hdrChanName{i}=char(temp);   i=i+1;end%char(chanName)% multiply by calibration factornewdata = NaN(length(in_arr), chan_count);if vers == 1.1   % do our simple en masse scaling   % the '300' applies IF the LabVIEW Channel Wizard   % is set up with  scaling: x30   scarr = in_arr * (300/65536);     %convert to degs   newdata = scarr;elseif vers >= 1.2   for jj = 1:chan_count      newdata(:,jj) = in_arr(:,jj) * (scaleval(jj)*10)/65536;   endelse   % version 1.0, (i.e. taken w/ the coil system)   % convert to degs   % do individual calibrations   scarr = in_arr * (range/65536);     %'range' comes from 'theirlvhdr.m'   % apply the calibration   for k = 1:chan_count      newdata(:,k) = scarr(:,k) .* calib(k);   endend% creating a time arrayt = (0:points-1)/samp_freq; t = t';commentstr = comments(end,:);commentstr = nameclean(commentstr);[dat_len, dat_cols] = size( newdata );if ~strcmpi(deblank(vpixx_stim),'no.vpx')   disp( ['VPixx stim:         ' vpixx_stim] );endif ~strcmpi(deblank(verge_stim),'no.vrg')   disp( ['vergence stim:      ' verge_stim] );enddisp( ['Channels found:     ' chnlstr2] );disp( ['Comments:           ' commentstr] );disp( ['Samples found:      ' num2str(dat_len)] );disp( ['Sampling frequency: ' num2str(samp_freq)] );disp( ['Record duration: ' num2str(dat_len/samp_freq) ' seconds'] );% offset and scale the dataapplybias% return to RD