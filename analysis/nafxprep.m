% nafxprep.m: does the scut work for preparing data segments for% analysis using the NAFX.%% Use 'zoomtool' to select the segment to be analyzed by using the cursors% to mark at least the beginning and end of the segment, and optionally,% the maximum and minimum extremes of foveation. Use the C1(x,y) and C2(x,y)% buttons to store the foveation points. (It is not necessary to store the% beginning and end points, but you may do so if you wish.)%% 'nafxprep' extracts the segment using the 'sub' function, names it% appropriately, shifts it in the same manner as 'calcshift' (also% producing an appropriately named variable), and then calculates the% velocity array (again appropriately named).%% The command line statements that would have been necessary to do this% work by hand are printed out, and the shifted position and velocity% segments are automatically placed into their fields in the NAFX GUI% (if it is currently open).% Written by: Jonathan Jacobs% April 2005 - June 2018  (last mod: 06/22/18)function nafxprep %%%%(chname)global xyCur1Mat xyCur2Mat xyCur1Ctr xyCur2Ctrdegstr=char(176); pmstr=char(177);temp=ver('MATLAB');ML_VER = str2double(temp.Version);% linelist is the list of existing lines; it is stored in NAFX gui UserData% it should initially be empty.nafxFig = findme('NAFXwindow');if ~ishandle(nafxFig)   disp('No NAFX controller found')   returnendtemp = nafxFig.UserData;h = temp{1};linelist = temp{2};samp_freq = str2double(h.sampFreqH.String);% find zoomtool windowif isempty(h.datawindow)   disp('You need to select and plot data to analyze.')   returnelse   figure(h.datawindow)end% We definitely need start and stop values. We may also need ymax and ymin.% Check to see if any values are stored in the xyCur matrices.%% cases:%  NO entries in xyCur matrices: use cur1x, cur2x as start/stop, and%    the min/max of the segment for calculating shift.%  TWO stored entries (1 ea. C1 & C2) in xyCur: compare against cur pos.%    Sort for min & max x and use them as start/stop. %    As above, min/max y are used for shift%  FOUR entries (2 ea/ C1 & C2): Sort them for min/max x,y. Ignore cursors.temp = size(xyCur1Mat); num_saved1 = temp(1);temp = size(xyCur2Mat); num_saved2 = temp(1);ch = get(gca,'Children');zoomedline = findobj(ch,'UserData','zoomed');if (num_saved1==0) || (num_saved2==0)   disp(' ')   disp('%%   You will need to use the cursors to select segment start and stop points and')   disp('%%   also the positions of the minimum and maximum foveation periods.')   disp('%%   Place Cursor 1 on the beginning of the desired segment and click the')   disp('%%   "C1 get" button to store its value. Place Cursor 2 on the endpoint of the segment')   disp('%%   and click the "C2 get" button. Next, locate the maximal foveation position and ')   disp('%%   select it with Cursor 1 and store its value. Finally, locate the minimal foveation')   disp('%%   position, select it with Cursor 2 and store its value. The "get" buttons should')   disp('%%   look like this: "C1 get (2)" and "C2 get(2)", showing that you have stored two')   disp('%%   locations for each cursor. These will be used to calculate the NAFX.')   disp(' ')   returnend% build the line list only as needed, i.e., whenever a line is selected see% if it is in the list. If it is, get the channel name. If not prompt user% to enter the name.%if nargin%   lineID = chname;%end%isInList = 0;%linelistlen = length(linelist);%for j = 1:linelistlen   if ML_VER >= 8.4      % matlab 2014b and later      %lineID = zoomedline.Tag;      chStr  = zoomedline.DisplayName;      %[lineID,~] = strtok(lineID, '.');   else      % matlab 2014a and earlier      %lineID = get(zoomedline);   end   %if strcmp(linelist{j,1}, lineID)   %   isInList = 1;   %   chStr = linelist{j,2};   %   break   %end%end% if ~isInList%    % add an entry (handle, name)%    linelist{linelistlen+1, 1} = lineID;%    commandwindow%    chStr = input('Enter the name of this data channel: ','s');%    if isempty(chStr)%       disp('Aborted.')%       return%    else%       linelist{linelistlen+1, 2} = chStr;%    end% else%    % use existing name%    %chStr = linelist{j,2};% end% save the linelist back into the nafx controls windowh.nafxFig.UserData=[{h},{linelist}];if num_saved1==0 || num_saved2==0   return      %mode = 'cursors';   %disp('% interval set by current cursor positions alone %')   %c1x = cur1horH.XData; c1x = c1x(1);   %c2x = cur2horH.XData; c2x = c2x(2);   %times = [c1x c2x];   elseif (num_saved1==1 && num_saved2>=1) || (num_saved1>=1 && num_saved2==1)   mode = 'mixed';   % get x,y values for cur1 and cur2   disp('% interval set by current AND stored cursor positions %')   cur1x = crsrloc(gca,1001); cur1x = cur1x(1);   cur2x = crsrloc(gca,2001); cur2x = cur2x(1);   cur1y = crsrloc(gca,1002); cur1x = cur1x(1);   cur2y = crsrloc(gca,2002); cur2x = cur2x(1);      % get LAST stored positions from xyCur matrices   mat1x = xyCur1Mat(end,1)/samp_freq;   mat1y = xyCur1Mat(end,2);   mat2x = xyCur2Mat(end,1)/samp_freq;   mat2y = xyCur2Mat(end,2);      % if saved times are same as cursor times, use x-axis lims as start/stop   if mat1x==cur1x || mat2x==cur2x      ga=gca;      temp=ga.XLim;      cur1x=temp(1);      cur2x=temp(2);   end   times = [cur1x cur2x mat1x mat2x];   ylist = [cur1y cur2y mat1y mat2y];   elseif num_saved1>=2 && num_saved2>=2   mode = 'storedpts';   % get LAST TWO stored positions from xyCur matrices   disp('% interval set by stored cursor positions alone %')   m1x1 = xyCur1Mat(end-1,1)/samp_freq;  m1y1 = xyCur1Mat(end-1,2);   m2x1 = xyCur2Mat(end-1,1)/samp_freq;  m2y1 = xyCur2Mat(end-1,2);   m1x2 = xyCur1Mat(end,1)/samp_freq;    m1y2 = xyCur1Mat(end,2);   m2x2 = xyCur2Mat(end,1)/samp_freq;    m2y2 = xyCur2Mat(end,2);      times = [m1x1 m1x2 m2x1 m2x2];   ylist = [m1y1 m1y2 m2y1 m2y2];endswitch mode   case {'cursors'}      tstart = min(times);      xstart = fix(samp_freq * tstart);      tstop = max(times);      xstop = fix(samp_freq * tstop);      ydata = zoomedline.YData;      ysub = ydata( xstart:xstop );      ymax = max(ysub);        ymin = min(ysub);   case {'mixed';'storedpts'}      % sort: xstart,xstop will be min,max x values      tstart = min(times);      %xstart = fix(samp_freq * tstart);      startobjtemp = find(times==min(times));      startobj=startobjtemp(1);      tstop  = max(times);      %xstop  = fix(samp_freq * tstop);      stopobjtemp = find(times==max(times));      stopobj = stopobjtemp(1);            times(startobj) = NaN;      times(stopobj)  = NaN;            % should be two non-NaN entries left in times list.      minmaxtimes = stripnan(times);      if length(minmaxtimes) ~= 2         disp('Error! too many entries in cursor array')         return      end      mm1str=num2str(minmaxtimes(1));      mm2str=num2str(minmaxtimes(2));            % ymin,ymax will be y-values of NON start/stop objects      ylistmin = ylist;      ylistmin(startobj) = NaN;      ylistmin(stopobj)  = NaN;            ylistmax = ylist;      ylistmax(startobj) = NaN;      ylistmax(stopobj)  = NaN;            ymin = min(ylistmin);      ymax = max(ylistmax);      end% from here on want to be independent of how x,y min&max are chosen.% adjust for possible non-zero initial time% (will have to subtract off one sample...)% need to fix this for case where no cursor values chosenstartStr = num2str( fix(tstart + 1/samp_freq(1)) );stopStr  = num2str( fix(tstop  + 1/samp_freq(1)) );% header formatted for pasting into log filehStr = [upper(chStr) ':  ('];hdrStr = ['% ' hStr num2str(tstart) ' - ' num2str(tstop) ' -- ' ...   num2str(tstop - tstart) ' sec)'];disp(hdrStr)%disp('cycles by manual count: ')%disp(' ')% What's the best way to get the eye movement data into here?% No way it can be what we're doing now: assume there is channel-based% data available in base workspace (ie, individual chans broken out from% the emData) and perform in-base evals on the literal names, putting THOSE results% into the base space, as well.% 1) For now, continue to assume individ chans in base. Get selected pos% data and grab it into here. perform shift&diff and put results into NAFX% figure's pos/vel array UserData.% 2) Eventually use rd and/or datstat to store data in NAFX window, and% then store sub-arrays in controls' UserData as above.% Calc and eval the position variable. Create subarray by operating on% array in base workspace. make a string of the literal command to evalcurr_dat_name = h.availDataH.String{h.availDataH.Value};evalin('base',[curr_dat_name ';']);varPosStr  = [chStr startStr '_' stopStr];evalStrPun = [varPosStr ' = sub(' chStr ',' num2str(tstart) ',' ...   num2str(tstop-tstart) ',' num2str(samp_freq) ');' ];disp(evalStrPun)evalin('base',evalStrPun);subPun = evalin('base',varPosStr);% calc and eval the SHIFTED position variableydiff  = abs(ymax-ymin);yshift = (ymax+ymin)/2;if yshift<0, shiftStr=' + '; else, shiftStr=' - '; endsubPsh = subPun-yshift;evalStrPsh = [varPosStr 's = ' varPosStr shiftStr num2str(abs(yshift)) ';' ];disp(evalStrPsh)%evalin('base',evalStrPsh)%subPsh = evalin('base',[varPosStr 's']);h.posArrayNAFXH.UserData = [{subPsh},{yshift}];subV = d2pt(subPsh,3,samp_freq);% calc and eval the velocity variablevarVelStr = [chStr 'v' startStr '_' stopStr];evalStrV = [varVelStr ' = d2pt(' varPosStr ', 3', num2str(samp_freq) ');'];disp(evalStrV)%evalin('base',evalStrV);%subV = evalin('base',varVelStr);h.velArrayNAFXH.UserData = {subV};% plug the shifted pos and vel strings into NAFX_gui window, if available% and set the position window popup menu to the next value larger than ydiff.nafxFig = findme('NAFXwindow');if get(nafxFig,'number')   %   global posArrayNAFXH velArrayNAFXH posLimNAFXH velLimNAFXH   h.posArrayNAFXH.String=[varPosStr 's'];   h.velArrayNAFXH.String=varVelStr;   xpos = [0.5 0.75 1.0 1.25 1.5 2.0 2.5 3.0 3.5 4.0 5.0 6.0];   temp = find((ydiff/2)<xpos);   % Fixed 7/8/14 to protect against overly large separations in foveation position selected   if isempty(temp)      pos_menu_val = length(xpos);      disp(' ')      disp('            ****** WARNING ******')      disp('Difference in foveation positions will require a window')      disp('greater than 6 deg. Window has been set to 6, but you should')      disp('consider reselecting your max and min foveation points to fit.')      disp(' ')   else      pos_menu_val = temp(1);   end      if ~isempty(pos_menu_val)      h.posLimNAFXH.Value=pos_menu_val;      disp(['% Min/max foveations occurred at: ' mm1str ' and ' mm2str ' seconds'])      disp(['% Min/max foveation separation: ' num2str(ydiff) degstr])      disp(['% Setting pos lim to ' pmstr num2str(xpos(pos_menu_val)) degstr])      h.velLimNAFXH.Value=1;      disp(['% Resetting vel lim to 4' degstr '/sec'])   endend% empty the xy cursor matrices in anticipation of next useif ~strcmp(mode,'cursors')   %zoomed_axes = h.datawindow.CurrentAxes;   %usr_dat = zoomed_axes.UserData;   %my_hand = usr_dat{2};   %clr1 = my_hand{15};   %clr2 = my_hand{16};   xyCur1Mat = [];  xyCur2Mat = [];   xyCur1Ctr = 0;   xyCur2Ctr = 0;   cursmatr('cur1_clr')   cursmatr('cur2_clr')   %disp(' ');   %disp('% Stored cursor positions have been cleared %');end