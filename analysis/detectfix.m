% detectfix.m: find fixation periods in a single plane.% Usage: [numfix, fixlist] = detectfix(pos)% Where 'pos' is the position array, fovlist is the set of all sample% indices that meet the velocity criterion (<4°/sec) for stable percept.% For 2-D data, call with each plane separately and then a third time with% the "AND" of the results from the first two calls.% Written by:  Jonathan Jacobs%              January 2017 (last mod: 01/25/17)function [numfix,fixptslist, missptslist, fpLen] = detectfix(posdata)global samp_freq% sacVelVal = 50;       % lower vel. limit for saccade blanking% sacAccVal = 2000;     % lower accel. limit for saccade blankingsacJerkVal = 100000;    % lower jerk limit for saccade blankinggapDur = 35;            % it's a gap if greater than this duration (in msec)minFovDur = 7;          % it's a fix if greater than this duration (in msec)velLim = 4; %% To be correct, we need n+1 sample points to properly represent a segment, i.e., adding% a terminus point.  For example, if the sample rate is 1000 Hz, the ISI is 1 msec, sofencepost = 0;                          % for low sample rates we will be more forgivingif samp_freq >= 250, fencepost = 1; end % for high sample rates we will be more exacting% we use jerk (4th derivative) to determine is a saccade is occurring.veldata  = d2pt(posdata,3,samp_freq);accdata  = d2pt(veldata,3,samp_freq);jerkdata = d2pt(accdata,3,samp_freq);gapSamp    = ceil(samp_freq/1000 * gapDur) + fencepost;minFovSamp = ceil(samp_freq/1000 * minFovDur) + fencepost;% we do not have a priori knowledge of where the subject's eyes are aimed% so we will only use vel slip (4 deg/sec) to decide when gaze is held.rawfix = find( abs(veldata) <= velLim );  % all points that are < slip vel% initially hit pts are the raw results (meet vel crit)% using this raw info we will create two arrays:%  -- "hits" array:   "1" = fov win pt%  -- "misses" array: "1" = non-fov win ptlastpt = rawfix(end);aa = zeros(lastpt,1);bb = ones(lastpt,1);aa(rawfix) = bb(rawfix);hits = aa;% Our approach is pretty simple:% first we FILL in any gaps shorter than the gap duration that appear% between "good" points (points that meet the pos/vel criteria)...% gapArray will contain the starting points of all the gaps% longer than gapSamp samples ( = gapDur msec)a = [rawfix' rawfix(end)]';b = [0 rawfix']';diffArray = a-b;gapArray = find( (diffArray<gapSamp) & (diffArray>1) );if isempty(gapArray) % no little guys to FILL    disp([' No gaps need to be filled (' num2str(gapDur) ' msec)'])else    gapArray = gapArray - 1;   % to mark the BEGINNING of the gap, not the end    if gapArray(1) == 0        gapArray = gapArray(2:end); % strip the leading zero    end        % walk along diffIndex, filling in the gaps    startPt = NaN*ones(size(gapArray));    endPt   = NaN*ones(size(gapArray));    lenFill = NaN*ones(size(gapArray));    for i = 1:length(gapArray)        % if we have a short enough gap we will fill in the "missing" pts,        % remembering that we can't fill in times during a saccade.        % (and a saccade can't be less than 3 samples +2 for beg&end)        startPt(i) = rawfix(gapArray(i));        endPt(i)   = rawfix(gapArray(i)+1);        lenFill(i) = endPt(i)-startPt(i)+1;        %isSac=0;        %isSac     = any(accIn(startPt(i):endPt(i))>=sacAccVal);        isSac      = any( abs(jerkdata(startPt(i):endPt(i)))>=sacJerkVal );        if ~isSac || lenFill(i) <= 5            hits(startPt(i):endPt(i)) = ones(lenFill(i),1);        end    endend% KILL all "good" segments that are too short.% segArray will contain the starting points of all the segments% shorter than minFixSamp samples (i.e. minFixDur msec)misses = find(hits==0);if isempty(misses), misses=1; enda = [misses' misses(end)]';b = [0 misses']';diffArray2 = a-b;segArray   = find( diffArray2>1 & diffArray2<=minFovSamp );if isempty(segArray)    % no little guys to KILL    disp([' No segments need to be removed (under ' num2str(minFovDur) ' msec)'])else    segArray = segArray - 1;          % to mark the BEGINNING of the segment    if segArray(1) == 0        segArray = segArray(2:end); % strip the leading zero    end    % walk along diffIndex2, killing the short segments    startPt2 = NaN*ones(size(segArray));    endPt2 = NaN*ones(size(segArray));    lenKill = NaN*ones(size(segArray));    for i = 1:length(segArray)        % if we have a too-short segment we will kill those pts        startPt2(i) = misses(segArray(i));        endPt2(i)   = misses(segArray(i)+1);        lenKill(i)  = endPt2(i)-startPt2(i)+1;        hits( startPt2(i):endPt2(i) ) = zeros(lenKill(i),1);    endend% Finally, we count the number of event clusters that are left.% These are (hopefully) our fixation periods.hits(1)=0; hits(2)=0;hits(length(hits))=0;fpStart=NaN(); fpStop=NaN();count=0;for i=2:length(hits)    if hits(i)~=hits(i-1)        if hits(i)==1             % found a beginning            count=count+1;            fpStart(count) = i;        else                      % found an ending            fpStop(count)  = i-1;        end    endendnumfix=count;fixptslist = find(hits==1);missptslist = find(hits==0);fpLen = fpStop-fpStart;return